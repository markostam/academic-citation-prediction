A Two-Stage Hybrid Algorithm
for Pickup and Delivery Vehicle
Routing Problems with Time Windows
Russell Bent and Pascal Van Hentenryck
Brown University, Box 1910 Providence, RI 02912, USA
{rbent,pvh}@cs.brown.edu
Abstract. This paper presents a two-stage hybrid algorithm for pickup
and delivery vehicle routing problems with time windows and multiple
vehicles (PDPTW). The ﬁrst stage uses a simple simulated annealing
algorithm to decrease the number of routes, while the second stage uses
LNS to decrease total travel cost. Experimental results show the eﬀec-
tiveness of the algorithm which has produced many new best solutions
on problems with 100, 200, and 600 customers. In particular, it has im-
proved 47% and 76% of the best solutions on the 200 and 600-customer
benchmarks, sometimes by as much as 3 vehicles. These results further
conﬁrm the beneﬁts of two-stage approaches in vehicle routing. They
also answer positively the open issue in the original LNS paper, which
advocated the use of LNS for the PDPTW and argue for the robustness
of LNS with respect to side-constraints.
1 Introduction
Multiple vehicle routing problems with time windows (VRPTW) have received
considerable attention in the last decades. These problems are often approached
by meta-heuritics, since problems with as few as 100 customers are currently
beyond the scope of state-of-the-art systematic search algorithms. Recent work
on the VRPTW has produced signiﬁcant improvements in solution quality and
execution time, often by combining several approaches or heuristics. Compara-
tively, little research was devoted to pickup and delivery problems with multiple
vehicles and time windows (PDPTW) until recently (e.g., [14,15,16,21]). Cus-
tomers in the PDPTW are divided into pickup and delivery pairs. Given such a
pair (p, d), a routing must service customers p and d with the same vehicle and
must schedule the pickup customer p before the delivery customer d. In standard
benchmarks [14], the goal is to minimize the number of used vehicles and, in case
of ties, the total travel cost.
The diﬃculty in pickup and delivery problems, which partly explains why
it is less studied than the VRPTW, lies in the side-constraints, which compli-
cate the neighborhoods and invalidate many of the traditional VRPTW moves
[18]. However, many practical applications naturally exhibit pickup and delivery
constraints in their modeling. This includes dial-a-ride problems, airline schedul-
ing, bus routing, tractor-trailer problems, helicopter support of oﬀshore oil ﬁeld
F. Rossi (Ed.): CP 2003, LNCS 2833, pp. 123–137, 2003.
c© Springer-Verlag Berlin Heidelberg 2003
124 Russell Bent and Pascal Van Hentenryck
platforms, and logistics and maintenance support [16]. More generally, indus-
trial vehicle routing problems are rarely pure and often feature side-constraints.
Because of its practical relevance and its side-constraints, the PDPTW is a nat-
ural model to evaluate the robustness and scalability of various approaches with
respect to side-constraints.
This paper proposes a two-stage hybrid algorithm for the PDPTW. The
overall structure of the algorithm is motivated by the recognition that minimizing
the objective function directly may not be the most eﬀective way to decrease the
number of routes in vehicle routing problems (e.g., [1,8]). Indeed, the objective
function often drives the search toward solutions with low travel cost, which may
make it diﬃcult to reach solutions with fewer routes but higher travel cost. To
overcome this limitation, our algorithm divides the search in two steps: (1) the
minimization of the number of routes and (2) the minimization of total travel
cost. This two-step approach makes it possible to design algorithms tailored to
each sub-optimization.
Our algorithm uses two distinct local search procedures to exploit the speci-
ﬁcities of each subproblem. The ﬁrst step uses a very simple simulated annealing
(SA) algorithm to minimize the number of routes. The SA algorithm only uses
relocation of pairs of customers and one of its key aspects is a lexicographic
evaluation function which minimizes the number of routes (primary criterion),
maximizes the sum of the squares of the route sizes (secondary criterion), and
minimizes travel cost of the routing plan (third criterion). The second criterion
was also used successfully in other applications (e.g., graph coloring [9] and,
more recently, vehicle routing [1]). The second step uses large neighborhood
search (LNS) [19] to minimize total travel cost. It is motivated by our expe-
rience that LNS is particularly eﬀective in minimizing total travel cost when
given a solution that minimizes the number of routes, and when the problem is
highly constrained [1]. The use of LNS for pickup and delivery problems was in
fact suggested in the original LNS paper [19], because of its ability to handle
side-constraints gracefully.
Experimental results on diﬃcult PDPTW problems demonstrate the eﬀec-
tiveness of the algorithm. On the standard 100, 200, and 600 customers bench-
marks [14], our algorithm produces 2, 25 (47%), and 46 (76%) new best solutions
respectively, while matching or being close to best known solutions on the other
instances. In several 600-customer instances, the algorithm decreases the num-
ber of vehicles by as much as 3. These results further conﬁrm the eﬀectiveness
of two-stage approaches in vehicle routing, answers positively the open question
in [19] on the potential of LNS for the PDPTW, and demonstrate the critical
role of the ﬁrst phase to boost LNS. Similarly, this research conﬁrms that the
structure of LNS makes it relatively easy to incorporate pickup and delivery
constraints in our previous hybrid algorithm [1], validating Shaw’s claim on the
robustness of LNS wrt side constraints.
The rest of this paper is organized as follows. Section 2 speciﬁes the PDPTW
and describes the notations. Section 3 gives an overview of the overall algorithm.
Section 4 presents the simulated annealing algorithm, while Section 5 describes
A Two-Stage Hybrid Algorithm 125
the LNS algorithm for minimizing travel costs. Section 6 presents the exper-
imental results. Section 7 discusses related work and Section 8 concludes the
paper.
2 Problem Formulation
This section deﬁnes the pickup and delivery vehicle routing problem with time
windows (PDPTW) and the various concepts used in this paper.
Customers. The problem is deﬁned in terms of N customers who are repre-
sented by the numbers 1, . . . , N and a depot represented by the number 0. The
set {0, 1, . . . , N} thus represents all the sites considered in the problem. We use
Customers to represent the set of customers and Sites to represent the set of
sites (The distinction between customers and sites simpliﬁes the formalization
of the problem and of the algorithm). We use Customersp and Customersd to
denote the pickup and delivery customers respectively. The travel cost between
sites i and j is denoted by cij . Travel costs satisfy the triangular inequality
cij + cjk ≥ cik. The normalized travel cost c′ij between sites i and j is deﬁned as
c′ij = cij / max
i,j∈Sites
cij .
Every customer i has a service time si ≥ 0. Given a pickup customer i, its
delivery counterpart is denoted by @i. Every pickup customer has a demand
qi ≥ 0 and its counterpart has demand q@i = −qi.
Vehicles. The PDPTW is deﬁned in terms of m identical vehicles. Each vehicle
has a capacity Q.
Routes. A vehicle route, or route for short, starts from the depot, visits a
number of customers at most once, and returns to the depot. In other words,
a route is a sequence 〈0, v1, . . . , vn, 0〉 or 〈v1, . . . , vn〉 for short, where all vi are
diﬀerent. The customers of a route r = 〈v1, . . . , vn〉, denoted by cust(r), is the
set {v1, . . . , vn}. We also use route(c) to represent the route of customer c. The
size of a route, denoted by |r|, is the number of customers |cust(r)|. The travel
cost of a route r = 〈v1, . . . , vn〉, denoted by t(r), is the cost of visiting all its
customers, i.e.,
t(r) = c0v1 + cv1v2 + . . . + cvn−1vn + cvn0.
if the route is not empty (n ≥ 1) and is zero otherwise.
Routing Plan. A routing plan is a set of routes {r1, . . . , rm} (m ≤ N) visiting
every customer exactly once, i.e.,
{⋃m
i=1 cust(ri) = Customers
cust(ri) ∩ cust(rj) = ∅ (1 ≤ i < j ≤ m)
126 Russell Bent and Pascal Van Hentenryck
Observe that a routing plan assigns a unique successor and predecessor to every
customer. These successors and predecessors are sites. The successor and prede-
cessor of customer i in routing plan σ are denoted by succ(i, σ) and pred(i, σ).
For simplicity, our deﬁnitions often assume an underlying routing plan σ and we
use i+ and i− to denote the successor and predecessor of i in σ.
Time Windows. The customers and the depot have time windows. The time
window of a site i is speciﬁed by an interval [ei, li], where ei and li represent the
earliest and latest arrival times respectively. Vehicles must arrive at a site before
the end of the time window li. They may arrive early but they have to wait until
time ei to begin service. Observe that e0 represents the time when all vehicles
in the routing plan leave the depot and that l0 represents the time when they
must all return to the depot. The departure time of customer i, denoted by δi,
is deﬁned recursively as{
δ0 = 0
δi = max(δi− + ci−i , ei) + si (i ∈ Customers).
The earliest service time of customer i, denoted by ai, is deﬁned as
ai = max(δi− + ci−i , ei) (i ∈ Customers).
The earliest arrival time of a route r = 〈v1, . . . , vn〉, denoted by a(r), is given by
δvn + cvn0 if the route is not empty and is e0 otherwise. A routing plan satisﬁes
the time window constraint for customer i if ai ≤ li. A routing plan σ satisﬁes
the time window constraint for the depot if ∀r ∈ σ : a(r) ≤ l0.
Capacities. The demand of a route r at customer c, denoted by q(c), is the
sum of demands of customers on r up to c, i.e.,
q(c) =
∑
i∈cust(r) & δi≤δc
qi.
The capacity constraint of a customer is satisﬁed if q(c) ≤ Q.
Pickup and Deliveries. The pickup and deliveries are represented by prece-
dence and coupling constraints. The precedence constraint of c ∈ Customersp
is satisﬁed if dc ≤ δ@c. Similarly, the coupling constraint of c is satisﬁed if
route(c) = route(@c).
The PDPTW. A solution to the PDPTW is a routing plan σ = {r1, . . . , rm}
satisfying the capacity constraints, time window constraints, and pickup and
delivery constraints, i.e.,

q(i) ≤ Q (i ∈ Customers)
a(rj) ≤ l0 (1 ≤ j ≤ m)
ai ≤ li (i ∈ Customers)
route(i) = route(@i) (i ∈ Customersp)
δi ≤ δ@i (i ∈ Customersp)
A Two-Stage Hybrid Algorithm 127
Function PDPTWoptimize
1. σ := RouteMinimize();
2. return TravelCostMinimize(σ);
Fig. 1. The Two-Stage Hybrid Algorithm for Minimizing Routes and Travel Costs.
The size of a routing plan σ, denoted by |σ|, is the number of non-empty routes
in σ, i.e., {r ∈ σ | cust(r) 	= ∅}. The PDPTW problem consists of ﬁnding a
solution σ which minimizes the number of vehicles and, in case of ties, the total
travel cost, i.e., a solution σ minimizing the objective function speciﬁed by the
lexicographic order
f(σ) = 〈|σ|,
∑
r∈σ
t(r)〉.
3 Overview of the Algorithm
Our algorithm is motivated by the recognition that minimizing the original ob-
jective function is not always the most eﬀective way to approach the problem.
Indeed, the objective function often drives the search towards solutions with low
travel costs. The reduction in the number of routes occurs more as a side-eﬀect
of the travel cost minimization than as a primary feature of the search. In addi-
tion, focusing on travel cost may make it extremely diﬃcult to reach solutions
with fewer routes since it may require considerable degradation of the travel cost
component of the objective function. To overcome this limitation, our algorithm
separates the optimization into two stages: the minimization of the number of
routes and the minimization of travel costs. Each of these two stages is opti-
mized by an algorithm exploiting the underlying structure of the subproblem.
(Of course, the second phase may sometimes reduce the number of vehicles as
well as a side-eﬀect of reducing travel distance.) The overall algorithm is de-
picted in Figure 1. The next two sections discuss each suboptimization in detail.
Observe that two-stage algorithms has been very successful on the traditional
VRPTW, where they have produced many new best solutions recently [1,8].
4 Minimizing the Number of Routes
The ﬁrst stage of our algorithm consists of minimizing the number of routes or,
equivalently, the number of vehicles used in the routing plan. It uses simulating
annealing [11] because of its success in reducing routes on the VRPTW and the
overall simplicity of its implementation.
4.1 The Neighborhood
The SA neighborhood is based on a simple pair relocation operator, which is also
used in [12,14,16]. Given a solution σ, N (σ) denotes the neighborhood of σ, i.e.,
128 Russell Bent and Pascal Van Hentenryck
the set of feasible solutions that can be reached from σ by using pair relocation,
which is deﬁned as follows.
Pair Relocation. For customers i, j, and k, ﬁrst place i after j, i.e., remove arcs
(i−, i), (i, i+), (j, j+) and add arcs (i−, i+), (j, i), and (i, j+). Second, place @i
after k, i.e., remove arcs (@i−,@i), (@i,@i+), (k, k+), and add arcs (@i−,@i+),
(k,@i), and (@i, k+).
A Random Sub-neighborhood. An interesting feature of our SA algorithm
is how it explores the neighborhood. Each iteration focuses on a (random) sub-
neighborhood of N obtained by randomly choosing a customer c from Cus-
tomers and by constructing all the pair relocations using c and @c. The sub-
neighborhood is explored exhaustively to determine whether it contains a solu-
tion improving the best available routing plan. We denote by N (c, σ) the subset
of N (σ) that can be reached by using pair relocation and customers c and @c.
4.2 The Evaluation Function
The evaluation function is another fundamental aspect of our simulated anneal-
ing algorithm. As mentioned earlier, the objective function 〈|σ|,∑r∈σ t(r)〉 is not
always appropriate, since it may lead the search to solutions with a small travel
cost and makes it impossible to remove routes. To overcome this limitation, our
simulated algorithm uses a more complex lexicographic ordering
e(σ) = 〈|σ|,−
∑
r∈σ
|r|2,
∑
r∈σ
t(r)〉.
especially tailored to minimize the number of routes. The ﬁrst component is,
of course, the number of routes. The second component maximizes
∑
r∈σ |r|2
which means that it favors solutions containing routes with many customers and
routes with few customers over solutions where customers are distributed more
evenly among the routes. The intuition is to guide the algorithm into removing
customers from some small routes and adding them to larger routes. Components
of this type are used on many problems, a typical example being graph coloring
[9]. The third component minimizes the travel cost of the routing plan.
4.3 The Simulated Annealing Algorithm
Figure 2 depicts the SA algorithm. The algorithm consists of a number of local
searches (lines 2-22), each of which start from the best solution found so far
and from the starting temperature. Each local search performs a number of
iterations (lines 5-20) and decreases the temperature (line 21). These two steps
are repeated until the time limit is exhausted or the temperature has reached its
lower bound. Lines 6-19 describe one iteration and are most interesting. Lines
6-8 compute the sub-neighborhood
N (c, σ) = 〈σ1, . . . , σs〉 where e(σi) ≤ e(σj) (i < j)
A Two-Stage Hybrid Algorithm 129
Function RouteMinimize
1. σb := getInitialSolution();
2. while (time < timeLimit) {
3. σ := σb;
4. t := startingTemperature;
5. while (time < timeLimit & t > temperatureLimit) {
6. for( i := 1; i ≤ maxIterations; i++) {
7. c := random(Customers);
8. 〈σ1, . . . , σs〉 := N(c,σ) where e(σi) ≤ e(σj) (i < j);
9. if e(σ1) < e(σb) then {
10. σb := σ1;
11. σ := σ1;
12. } else {
13. r := random([0, 1])β × s;
14. ∆ := e(σ) − e(σr);
15. if ∆ ≥ 0 then
16. σ := σr;
17. else if random([0, 1]) ≤ e∆/t then
18. σ := σr;
19. }
20. }
21. t := α × t;
22. }
23. }
24. return σb;
Fig. 2. The Simulated Annealing Algorithm to Minimize the Number of Routes.
for a random customer. Lines 9-11 select the solution σ1 minimizing f in N (c, σ)
if it improves the best solution found so far. These lines introduce an aspiration
criterion [5] in the simulated annealing algorithm. Lines 13-18 are the core of the
algorithm. Line 13 chooses a random element σr ∈ N (c, σ) and σr is selected
as the next routing plan if it does not degrade the current solution (line 15)
or with the traditional probability of simulated annealing otherwise (line 17).
Observe also line 13 which biases the search towards “good” moves in N (c, σ)
when β > 1.
5 Minimizing the Travel Cost
Our algorithm uses large neighborhood search (LNS) to minimize travel cost.
LNS was proposed in [19] for the VRPTW, where it was shown particularly
eﬀective on the class 1 problems from the Solomon benchmarks, producing sev-
eral improvements over the then best published solutions. However, the algo-
rithm performed poorly on the class 2 benchmarks where it could not reduce the
number of routes satisfactorily [19] (Our own experimental results conﬁrm the
130 Russell Bent and Pascal Van Hentenryck
ﬁndings of [19] on pickup and delivery problems). By separating the overall opti-
mization in two stages, our algorithm directly addresses this LNS weakness and
exploits its strength in minimizing travel cost. The rest of this section describes
the LNS algorithm in detail. In general, the algorithm adapts the heuristics and
strategies described in [19], although it departs on a number of issues which are
critical to scale LNS to large-scale problems.
The Neighborhood and the Evaluation Function. Given a solution σ,
the neighborhood of LNS, denoted by NR(σ), is the set of solutions that can
be reached from σ by relocating at most p pairs of customers (where p is a
parameter of the implementation). Since LNS also uses subneighborhoods and
explores them in a speciﬁc order, we use additional notations. In particular,
NR(σ, S) denotes the set of solutions that can be reached from σ by relocating
the customers in S. Also, given a partial solution σ with customers Customers\S,
NI(σ, S) denotes the solutions that can be obtained by inserting the customers
S in σ. Finally, LNS uses the original objective function, which involves the
number of routes. This is important since, in some cases, minimizing travel costs
makes it possible to decrease the number of routes further.
The Algorithm. At a high level, the LNS algorithm can be seen as a local
search where each iteration selects a neighbor σc in NR(σb) and accepts the
move if f(σc) < f(σb). It can be formalized as follows:
for(i := 1;i ≤ maxIterations; i++) {
select σc ∈ NR(σb);
if f(σc) < f(σb) then
σb := σc;
}
In practice, it is important to reﬁne and extend the above algorithm in three
ways. The ﬁrst modiﬁcation consists of exploring the neighborhood by increasing
number of allowed relocations. The second change generalizes the algorithm to a
sequence of local searches. The third modiﬁcation consists of exploring the sub-
neighborhood NR(σb, S) more exhaustively to ﬁnd its best solution. The overall
algorithm is depicted in Figure 3. Observe line 2 which adds another loop, line 4
which selects a set of customers S of size 2n, line 5 which selects a best neighbor
in NR(σb, S), and line 8 which reinitializes the number of allowed iterations.
In fact, the algorithm is now very close to variable neighborhood search [6]. It
remains to describe how to select customers and how to implement line 5 in the
above algorithm.
Selecting Customers to Relocate. The LNS algorithm adapts the tradi-
tional customer selection [19] to the PDPTW. The implementation is depicted
in Figure 4. It ﬁrst selects a customer pair randomly (lines 1-2) and iterates lines
4-7 to remove the n − 1 remaining customer pairs. Each such iteration selects a
pickup customer from S (the already selected customers) and ranks the remain-
ing pickup customers according to a relatedness criterion (lines 4-5). The new
A Two-Stage Hybrid Algorithm 131
Function TravelCostMinimize(σb)
1. for(l := 1;l ≤ maxSearches; l++)
2. for(n := 1;n ≤ p; n++)
3. for(i := 1;i ≤ maxIterations; i++) {
4. S := SelectCustomers(σb, n);
5. select σc ∈ NR(σb, S) such that f(σc) = minσ∈NR(σb,S)f(σ);
6. if f(σc) < f(σb) then {
7. σb := σc;
8. i := 1;
9. }
Fig. 3. The LNS Algorithm to Minimize Travel Cost.
Function SelectCustomers(σ,n)
1. c := { random(Customersp) };
2. S := {c,@c};
3. for(i := 2;i ≤ n; i++) {
4. c := random(S ∩ Customersp);
5. 〈c0, . . . , cN
2 −i
〉 := Customersp \ S such that
relateness(c, ci) ≥ relateness(c, cj) (i ≤ j);
6. r := random([0, 1])β × |Customersp \ S|;
7. S := S ∪ {cr,@cr};
8. }
Fig. 4. Selecting Customers in the LNS Algorithm.
customer to insert is randomly selected in line 6 and, once again, the algorithm
biases the selection toward related neighbors. The relatedness measure is deﬁned
as in [19]:
relateness(i, j) =
1
c′ij + vij
where vij = 1 if route(i) 	= route(j) and is zero otherwise.
The Exploration Algorithm. Our LNS algorithm uses a branch and bound
algorithm to explore the selected sub-neighborhood. The algorithm is depicted in
Figure 5. If the set of customers to insert is empty, the algorithm checks whether
the current solution improves the best solution found so far. Otherwise, it selects
the customer pair whose best insertion degrades the objective function the most.
The algorithm then explores all the partial solutions obtained by inserting c
and @c by increasing order of their travel costs. Also, observe that only the
partial solutions whose lower bounds are better than the best solution found
so far are explored by the algorithm. The lower bound satisﬁes the inequality
Bound(σ, S) ≤ minσ′∈NI(σ,S) f(σ′).
132 Russell Bent and Pascal Van Hentenryck
Function LDSexplore(σc,S,σb,d,dmax)
1. if d ≤ dmax then {
2 if S = ∅ then {
3. if f(σc) < f(σb) then σb := σc;
4. } else {
5. c := arg-maxc∈S minσ∈NI (σ,{c,@c}) f(σ);
6. Sc := S \ {c,@c};
7. 〈σ0, . . . , σk〉 := NI(σ, {c,@c}) where f(σi) ≤ f(σj) (i ≤ j);
8. for(i := 1; i ≤ k; i++) {
9. if Bound(σi, Sc) < f(σb) then {
10. LDSexplore(σi, Sc, σb, d, dmax);
11. d := d + 1;
12. }
13. }
14. }
15. }
Fig. 5. The Branch and Bound Algorithm with a Limited Discrepancy Strategy.
The bounding function is the cost of a minimum spanning k-tree [4] on the
insertion graph with the depot as distinguished vertex, generalizing the well-
known 1-tree bound of the traveling salesman problem. The insertion graph
vertices are the customers. Given a solution σ over customers C = ∪r∈σcust(r)
and a set S of vertices to insert, the insertion graph edges come from three
diﬀerent sets:
1. the edges already in σ;
2. all the edges between customers in S;
3. all the feasible edges connecting a customer from C and a customer from S.
For large-scale problems, ﬁnding the best reinsertion is too time-consuming.
Our algorithm uses limited discrepancy search (LDS) [7] to explore only a small
part of the search tree. More precisely, it only uses one LDS phase which allows
up to d discrepancies. Note that the tree is not binary and the heuristic selects
the insertion points by increasing lower bounds.
Observe also that the neighborhood NI(σ, {c,@c}) is of size O(N2). On large-
scale problems or on problems with wide time windows, the computation cost
of maintaining this neighborhood during branching can become quite expensive.
To overcome this diﬃculty, our algorithm only maintains the y best feasible
insertion points found initially (where y is an implementation parameter). This
approximation is critical to scale LNS to large-scale problems.
6 Experimental Results
This section reports preliminary experimental results on the algorithm. All re-
sults are given on a 1.2Ghz AMD Athlon Thunderbird K7 processor running
A Two-Stage Hybrid Algorithm 133
Table 1. 100 Customers.
Best SA/LNS Best SA/LNS
V TD Pub V TD Time V TD Pub V TD Time
lc101 10 828.937 LL 10 828.937 0.00 lc201 3 591.557 LL 3 591.557 0.00
lc102 10 828.937 LL 10 828.937 0.00 lc202 3 591.557 LL 3 591.557 0.00
lc103 9 1082.35 SAM 9 1035.35 0.02 lc203 3 585.564 LL 3 591.173 0.00
lc104 9 860.011 SAM 9 860.011 0.33 lc204 3 590.599 SAM 3 590.599 4.47
lc105 10 828.937 LL 10 828.937 0.00 lc205 3 588.876 LL 3 588.876 0.00
lc106 10 828.937 LL 10 828.937 0.00 lc206 3 588.493 LL 3 588.493 0.00
lc107 10 828.937 LL 10 828.937 0.01 lc207 3 588.286 LL 3 588.286 0.00
lc108 10 826.439 LL 10 826.439 0.00 lc208 3 588.324 LL 3 588.324 0.00
lc109 9 1027.60 SAM 9 1000.6 42.57
lr101 19 1650.80 LL 19 1650.80 0.00 lr201 4 1253.23 SAM 4 1253.23 0.01
lr102 17 1487.57 LL 17 1487.57 0.01 lr202 3 1197.67 LL 3 1197.67 0.01
lr103 13 1292.68 LL 13 1292.68 0.01 lr203 3 949.396 LL 3 949.396 0.13
lr104 9 1013.39 LL 9 1013.39 0.00 lr204 2 849.05 LL 2 849.05 0.53
lr105 14 1377.11 SAM 14 1377.11 0.00 lr205 3 1054.02 LL 3 1054.02 0.01
lr106 12 1252.62 LL 12 1252.62 0.00 lr206 3 931.625 LL 3 931.625 0.78
lr107 10 1111.31 LL 10 1111.31 0.00 lr207 2 903.056 LL 2 903.056 0.01
lr108 9 968.966 LL 9 968.966 0.00 lr208 2 734.848 LL 2 734.848 0.01
lr109 11 1208.96 SAM 11 1208.96 0.00 lr209 3 930.586 SAM 3 930.586 12.97
lr110 10 1159.35 LL 10 1159.35 0.00 lr210 3 964.224 LL 3 964.224 0.04
lr111 10 1108.90 LL 10 1108.9 0.00 lr211 2 884.294 LL 2 913.837 1.23
lr112 9 1003.77 LL 9 1003.77 0.00
lrc101 14 1708.70 SAM 14 1708.70 0.00 lrc201 4 1406.94 SAM 4 1406.94 0.14
lrc102 12 1558.07 SAM 12 1558.07 0.00 lrc202 3 1374.27 LL 3 1374.27 0.01
lrc103 11 1258.74 LL 11 1258.74 0.00 lrc203 3 1089.07 LL 3 1089.07 0.01
lrc104 10 1128.40 SAM 10 1128.40 0.01 lrc204 3 818.67 SAM 3 818.663 0.18
lrc105 13 1637.62 SAM 13 1637.62 0.00 lrc205 4 1302.20 LL 4 1302.20 0.05
lrc106 11 1424.73 SAM 11 1424.73 0.00 lrc206 3 1159.03 SAM 3 1159.03 0.01
lrc107 11 1230.14 SAM 11 1230.14 0.00 lrc207 3 1062.05 SAM 3 1062.05 0.05
lrc108 10 1147.43 SAM 10 1147.43 0.00 lrc208 3 852.758 LL 3 852.758 0.11
Linux, using g++ with the -O ﬂag, and double precision ﬂoating-point numbers.
The results are rounded to six signiﬁcant digits. Our experimental results use
the standard PDPTW benchmarks available at
http://www.sintef.no/static/am/opti/projects/top/vrp/benchmarks.html
See [14] for their descriptions. For prior results, we use the abbreviations LL=[14]
and SAM=[21].
Our algorithm was run with a ﬁxed conﬁguration on all benchmarks, which is
necessarily suboptimal, in order to demonstrate the robustness of the algorithm
across many diﬀerent problems. Simulated annealing was allowed to run for 5
minutes, with initial temperature of 2000, cooling factor of 0.95, 2500 iterations
per temperature, a minimum temperature of 0.01, and β = 10. LNS was run
with a maximum customer pairs removed of 18, 500 attempts for each removal
size, 15 as the relatedness determinism, 3 discrepancies, and 15 initial insertion
points maintained for each pair removed. LNS is allowed 60 minutes to ﬁnd a
solution (90 minutes for the 600-customer benchmarks) although, in practice, it
ﬁnds the best solution much quicker in many cases.
Tables 1, 2, and 3 report the experimental results for 100, 200, and 600
customers. The tables compare our algorithm with the best known solutions on
these standard benchmarks. For each benchmark, we give the number of vehicles
and the travel cost of the best known solution, as well as the best solutions found
by our algorithm among 5 runs (10 for the 600-customer instances). We also
134 Russell Bent and Pascal Van Hentenryck
Table 2. 200 Customers.
Best SA/LNS Best SA/LNS
V TD Pub V TD Time V TD Pub V TD Time
lc1 2 1 20 2704.57 LL 20 2704.57 0.00 lc2 2 1 6 1931.44 SAM 6 1931.44 0.00
lc1 2 2 19 2764.56 LL 19 2764.56 0.05 lc2 2 2 6 1881.40 SAM 6 1881.40 0.09
lc1 2 3 18 2772.18 SAM 17 3134.08 26.78 lc2 2 3 6 1845.54 SAM 6 1844.33 2.05
lc1 2 4 17 2708.90 SAM 17 2693.41 14.29 lc2 2 4 6 1767.12 SAM 6 1778.54 5.63
lc1 2 5 20 2702.05 LL 20 2702.05 0.00 lc2 2 5 6 1891.21 LL 6 1891.21 0.00
lc1 2 6 20 2701.04 LL 20 2701.04 0.00 lc2 2 6 6 1857.78 SAM 6 1857.78 0.05
lc1 2 7 20 2701.04 LL 20 2701.04 0.05 lc2 2 7 6 1850.13 SAM 6 1850.13 0.01
lc1 2 8 20 2689.83 SAM 20 2689.83 0.09 lc2 2 8 6 1824.34 LL 6 1824.34 3.87
lc1 2 9 18 2724.24 LL 18 2724.24 0.36 lc2 2 9 6 1854.21 SAM 6 1854.21 1.32
lc1 2 10 18 2741.56 LL 18 2741.56 1.00 lc2 2 10 6 1817.45 SAM 6 1817.45 0.27
lr1 2 1 20 4819.12 SAM 20 4819.12 2.07 lr2 2 1 5 4073.10 SAM 5 4073.10 1.58
lr1 2 2 18 4228.21 SAM 17 4666.09 1.86 lr2 2 2 4 3796.16 LL 4 3796.00 7.36
lr1 2 3 15 3761.52 LL 15 3657.19 3.53 lr2 2 3 4 3100.03 SAM 4 3100.38 46.49
lr1 2 4 11 2968.57 SAM 10 3146.06 21.41 lr2 2 4 3 2754.96 SAM 3 2956.15 30.14
lr1 2 5 17 4331.14 SAM 16 4760.18 5.22 lr2 2 5 4 3438.39 SAM 4 3438.39 2.46
lr1 2 6 15 4068.74 SAM 14 4175.16 2.03 lr2 2 6 4 3201.54 SAM 4 3208.53 16.74
lr1 2 7 13 3190.75 SAM 12 3851.36 7.12 lr2 2 7 3 3190.75 LL 3 3337.28 41.52
lr1 2 8 10 2718.23 SAM 9 2871.67 41.18 lr2 2 8 3 2295.44 SAM 3 2407.66 39.59
lr1 2 9 15 4224.35 SAM 14 4411.54 37.14 lr2 2 9 4 3198.44 SAM 4 3198.44 1.59
lr1 2 10 12 3654.80 LL 11 3744.95 4.70 lr2 2 10 3 3447.42 SAM 3 3478.67 44.10
lrc1 2 1 19 3606.06 SAM 19 3606.06 0.06 lrc2 2 1 7 2997.06 SAM 6 3690.10 10.80
lrc1 2 2 16 3621.30 SAM 15 3681.36 47.48 lrc2 2 2 6 2674.16 SAM 6 2666.01 0.41
lrc1 2 3 14 3255.33 SAM 13 3161.75 27.06 lrc2 2 3 5 2620.85 SAM 5 2523.59 53.78
lrc1 2 4 10 2890.02 SAM 10 2655.27 10.67 lrc2 2 4 4 2202.89 SAM 4 2795.7 4.94
lrc1 2 5 16 3750.52 SAM 16 3715.81 2.20 lrc2 2 5 5 2785.75 SAM 5 2776.93 2.86
lrc1 2 6 17 3368.66 SAM 17 3368.66 0.97 lrc2 2 6 5 2707.75 SAM 5 2707.96 2.51
lrc1 2 7 16 3326.18 SAM 15 3417.16 17.17 lrc2 2 7 5 2546.77 SAM 4 3050.03 16.67
lrc1 2 8 14 3164.50 LL 14 3087.62 14.99 lrc2 2 8 4 2442.04 SAM 4 2401.84 40.99
lrc1 2 9 15 3100.88 SAM 14 3129.65 20.97 lrc2 2 9 4 2209.94 SAM 4 2750.30 23.75
lrc1 2 10 13 2884.71 SAM 13 2833.85 56.06 lrc2 2 10 4 2059.16 SAM 3 2699.55 31.46
report the time in minutes taken by LNS to the best solution (the simulating
annealing time being ﬁxed). Bold-face entries indicate improvement over the best
known solution.
The tables indicate that our algorithm produces very high-quality solutions
across the board. For 100 customers, it produces two new best solutions and
matches 54 (93%). For 200 customers, it improves 28 (47%) best solutions and
matches 24 (40%). For 600 customers, it produces 46 new solutions (77%), while
matching 5 more (8%). Since previous work does not report computation times,
it is impossible to make comparisons. Most 100-customer instances are solved
quickly, spending little time in LNS in almost all instances. On the 200-customer
instances, the variation in running time is much larger and can range from a
few seconds to almost an hour. The 600-customer instances spend signiﬁcant
amounts of time in LNS. Note that these times are comparable to those of our
state-of-the-art VRPTW algorithm [1].
In summary, these preliminary results are extremely encouraging and demon-
strate that the approach produces very high-quality results in reasonable times.
7 Discussion and Related Work
This paper originated as an attempt to generalize our hybrid algorithm for the
VRPTW to pickup and delivery problems. The hope was to validate the claim
A Two-Stage Hybrid Algorithm 135
Table 3. 600 Customers.
Best SA/LNS Best SA/LNS
V TD Pub V TD Time V TD Pub V TD Time
lc1 6 1 60 14095.6 LL 60 14095.6 0.01 lc2 6 1 19 7977.98 SAM 19 7977.98 0.88
lc1 6 2 59 14164.0 LL 58 14379.5 1.96 lc2 6 2 19 8483.50 SAM 19 8253.67 19.06
lc1 6 3 54 15920.6 SAM 51 14569.3 46.45 lc2 6 3 18 7500.13 SAM 18 7436.50 64.37
lc1 6 4 48 13567.5 SAM 48 13750.6 89.21 lc2 6 4 18 8513.88 LL 18 9479.88 89.99
lc1 6 5 60 14086.3 LL 60 14086.3 0.82 lc2 6 5 19 8596.84 LL 19 8047.37 53.37
lc1 6 6 60 14090.8 LL 60 14090.8 0.51 lc2 6 6 19 8328.40 SAM 19 8237.58 53.36
lc1 6 7 60 14083.8 LL 60 14083.8 0.82 lc2 6 7 19 8704.89 SAM 19 8038.56 48.81
lc1 6 8 59 14670.4 SAM 59 14554.3 11.32 lc2 6 8 18 8147.00 LL 19 7855.38 88.57
lc1 6 9 56 14993.4 LL 55 14648.1 85.44 lc2 6 9 19 8258.20 SAM 19 8304.29 43.55
lc1 6 10 57 15337.7 LL 54 14870.3 59.96 lc2 6 10 18 7963.86 SAM 18 7853.27 55.24
lr1 6 1 59 24149.1 SAM 59 22838.3 53.04 lr2 6 1 12 18842.4 SAM 12 18840.8 23.63
lr1 6 2 46 22854.4 SAM 45 20985.7 55.46 lr2 6 2 11 20243.4 LL 11 22348.2 59.90
lr1 6 3 37 19975.6 LL 37 18685.9 82.16 lr2 6 3 10 17855.1 SAM 10 16657.5 59.69
lr1 6 4 28 14717.3 SAM 28 14199.9 86.05 lr2 6 4 7 14595.6 SAM 7 14223.2 82.71
lr1 6 5 42 21750.6 SAM 40 22188.8 78.88 lr2 6 5 11 15907.5 SAM 10 21250.1 88.26
lr1 6 6 37 20376.7 SAM 35 20406.2 59.73 lr2 6 6 10 19160.3 SAM 9 21722.8 89.44
lr1 6 7 31 16709.3 SAM 28 16963.8 86.42 lr2 6 7 8 16778.0 LL 8 16262.0 59.80
lr1 6 8 21 12978.3 SAM 21 12620.1 88.01 lr2 6 8 8 11671.2 SAM 6 13344.1 38.08
lr1 6 9 37 21821.2 SAM 34 21273.3 88.05 lr2 6 9 10 18791.2 SAM 9 18853.4 58.22
lr1 6 10 30 19120.7 LL 29 18373.9 59.09 lr2 6 10 8 19070.6 SAM 8 18869.2 17.08
lrc1 6 1 54 18251.2 SAM 53 17930.0 24.34 lrc2 6 1 17 13172.6 SAM 17 13111.6 22.16
lrc1 6 2 47 16736.9 SAM 45 16040.3 32.52 lrc2 6 2 15 11587.8 SAM 15 11463.0 55.74
lrc1 6 3 39 15525.2 SAM 36 14407.6 54.82 lrc2 6 3 13 12428.64 SAM 11 15167.3 78.21
lrc1 6 4 27 12138.4 SAM 25 11308.6 89.82 lrc2 6 4 11 8282.80 SAM 8 12512.5 89.42
lrc1 6 5 49 17368.4 SAM 47 16803.9 87.75 lrc2 6 5 15 12401.5 SAM 15 12309.7 46.47
lrc1 6 6 48 17869.8 SAM 45 17126.4 89.60 lrc2 6 6 13 12679.3 SAM 14 12894.1 72.36
lrc1 6 7 42 16020.3 SAM 40 15493.5 59.15 lrc2 6 7 12 12998.4 SAM 12 13851.5 38.01
lrc1 6 8 37 15626.0 LL 36 15352.6 58.93 lrc2 6 8 12 10898.3 SAM 12 11877.8 89.35
lrc1 6 9 37 15342.6 SAM 37 15253.7 71.08 lrc2 6 9 11 11917.2 SAM 11 14810.5 56.60
lrc1 6 10 34 14137.5 SAM 33 13830.5 59.25 lrc2 6 10 10 13165.4 SAM 9 12874.8 73.08
in [19] that LNS should handle side-constraints gracefully. The algorithm pre-
sented here keeps the two-stage approach of the original algorithm, but it diﬀers
in several important ways. First, the SA algorithm was no longer able to use the
wealth of moves available for the VRPTW. It is now based on a single move,
pair relocation, which is also used in other algorithms for the PDPTW [12,16].
However, despite its simplicity, the SA algorithm boosts the quality of LNS sig-
niﬁcantly, since LNS cannot decrease the number of vehicles suﬃciently on many
benchmarks. The LNS adaptation to the PDPTW was less drastic. The key idea
is to select and reinsert pickup and delivery customers in pairs. Additional ap-
proximations, i.e., maintaining only a subset of the insertion points, was also
necessary to obtain high-quality solutions on large-scale problems and problems
with many customers.
Single vehicle pickup and delivery problems were ﬁrst introduced by [17] in
1980. Small instances of multiple vehicle problems with time windows were in-
troduced and solved optimally in [3]. A good survey of the various models and
techniques utilized in early work on pickup and delivery problems can be found
in [18]. More recent advances on multiple vehicle problems has focused on meta-
heuristics including tabu search and simulated annealing. Tabu search was used
in [12,16] to minimize another objective function, i.e., total schedule duration,
in pickup and delivery problems. They use pair relocation as one of their neigh-
borhood operators to move customers between routes. They also introduced pair
136 Russell Bent and Pascal Van Hentenryck
exchange operators and a single customer relocation within the same route. A
tabu search/simulated annealing hybrid was successfully used in [14] to solve
the PDPTW. This algorithm was compared in detail in the experimental sec-
tion. Excellent results were also produced in [21] but the report is not available
unfortunately. A squeaky wheel algorithm was also proposed in [15], but it does
not seem to be competitive with the two earlier algorithms in solution quality.
8 Conclusion
This paper proposed a two-stage hybrid algorithm for pickup and delivery vehi-
cle routing problems with multiple vehicles and time windows (PDPTW). The
algorithm minimizes the number of vehicles using simulated annealing in the ﬁrst
stage, and minimizes travel cost using LNS in the second stage. Experimental
results show the eﬀectiveness of the approach which produced many new best
solutions on instances with 100, 200, and 600 customers.
More precisely, the results demonstrate that the two-stage approach boosts
the solution quality of LNS signiﬁcantly, that a simple simulated annealing algo-
rithm is excellent in reducing the number of vehicles, and that LNS, with appro-
priate reductions in its underlying search space, is very eﬀective in optimizing
travel cost. The paper also settles positively the open issue in the original LNS
paper, which advocated the use of LNS for the PDPTW because of its ability to
handle side-constraints gracefully. More generally, these results seem to indicate
that a two-step approach, combining SA and LNS, should produce high-quality
results for vehicle routing problems with additional side-constraints.
There are many open issues that deserve attention. As research moves to
large-scale problems involving several hundreds or thousands of customers, scal-
ing the algorithms raise new interesting challenges that were not systematically
studied here. It is indeed unlikely that the same algorithmic conﬁguration would
perform eﬀectively on all instances. It would be interesting to study the impact
of various decisions on the behaviour of the algorithm and to study how to tune
these decisions dynamically during search. It is also clear that a unique algo-
rithm does not exist for all purposes. It would be interesting to study algorithms
producing high-quality results for the PDPTW in short times, even if there is
some decrease in solution quality and robustness. Finally, it is of great interest
to evaluate the approach on complex problems with additional side-constraints.
Obviously, progress in that respect will strongly depend on the availability of
such complex instances.
Acknowledgments
This work is partly supported by an NDSEG fellowship from (ASEE) and an
NSF ITR DMI-0121495 and ACI-0121497 awards.
References
1. Bent, R. and Van Hentenryck, P. A Two-Stage Hybrid Local Search for the Vehicle
Routing Problem with Time Windows. Transportation Science (to appear).
A Two-Stage Hybrid Algorithm 137
2. Chiang, W. and Russell, R. Simulated Annealing Metaheuristics for the Vehicle
Routing Problem with Time Windows. Annals of Operations Research, 63:3–27
(1996).
3. Dumas, Y., Desrosiers, J. and Soumis, F. The Pickup and Delivery Problem with
Time Windows European Journal of Operational Research, 54:7–22. (1991).
4. Fisher, M., Joernsten, K., and Madsen, O. Vehicle routing with time windows:
Two optimization algorithms. Operations Research, 45(3):488–492 (1997).
5. Glover, F. Tabu Search. Orsa Journal of Computing, 1:190–206 (1989).
6. Hansen, P. and Mladenovic, N. An introduction to variable neighborhood search.
In Voss, S., Martello, S., Osman, I. H., and Roucairol, C., editors, Meta-heuristics,
Advances and Trends in Local Search Paradigms for Optimization, pages 433–458.
Kluwer Academic Publishers (1998).
7. Harvey, W. and Ginsberg, M. Limited Discrepancy Search. In Proceedings of
IJCAI-95, Montreal, Canada (1995).
8. Homberger, J. and Gehring, H. Two Evolutionary Metaheuristics for the Vehicle
Routing Problem with Time Windows. INFOR, 37:297–318 (1999).
9. Johnson, D., Aragon, C., McGeoch, L., and Schevon, C. Optimization by Simulated
Annealing: An Experimental Evaluation; Part II, Graph Coloring and Number
Partitioning. Operations Research, 39(3):378–406 (1991).
10. Kindervater, G. and Savelsbergh, M. Vehicle Routing: Handling Edge Exchanges.
In Aarts, E. and Lenstra, J., editors, Local Search in Combinatorial Optimization,
chapter 10, pages 337–360. John Wiley & Sons Ltd (1997).
11. Kirkpatrick, S., Gelatt, C., and Vecchi, M. Optimization by Simulated Annealing.
Science, 220:671–680 (1983).
12. Lau, H. and Liang, Z. Pickup and Delivery with Time Windows: Algorithms
and Test Case Generations In Proceedings of the 13th IEEE Conf. on Tools with
Artiﬁcial Intelligence (ICTAI), 333-340 (2001).
13. Lenstra, J. and Rinnooy Kan, A. H. G. Complexity of Vehicle Routing and Schedul-
ing Problems. Networks, 11:221–227 (1981).
14. Li, H. and Lim, A. A Metaheuristic for the Pickup and Delivery Problem with
Time Windows In 13th IEEE International Conference on Tools with Artiﬁcial
Intelligence (ICTAI), 160–170 (2001).
15. Lim, H., Lim, A., and Rodrigues, B. Solving the Pickup and Delivery Problem
with Time Windows Using Squeaky Wheel Optimization with Local Search In
American Conference on Information Systems (AMCIS), (2002)
16. Nanry, W. and Barnes, J. Solving the Pickup and Delivery Problem with Time
Windows Using Reactive Tabu Search Transportation Research Part B, 34:107–121
(2000).
17. Psaraﬁs, H. A Dynamic Programming Solution to the Single Vehicle Many-to-
Many Immediate Request Dial-A-Ride Problem Transportation Science, 14:130–
154 (1980).
18. Savelsbergh, M and Sol, M. The General Pickup and Delivery Problem Trans-
portation Science, 29 (1):107–121 (1995).
19. Shaw, P. Using Constraint Programming and Local Search Methods to Solve
Vehicle Routing Problems. In Principles and Practice of Constraint Programming,
pages 417–431 (1998).
20. Solomon, M. Algorithms for the Vehicle Routing and Scheduling Problems with
Time Window Constraints. Operations Research, 35 (2):254–265 (1987).
21. Unpublished Results SINTEF Applied Mathematics-Department of Optimisation,
Technical Report in Progress
http://www.sintef.no/static/am/opti/projects/top/vrp/benchmarks (2003).
