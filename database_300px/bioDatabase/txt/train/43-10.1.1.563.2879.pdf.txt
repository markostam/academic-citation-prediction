Journal of Artiﬁcial Intelligence Research 29 (2007) 269-307 Submitted 8/06; published 7/07
Semantic Matchmaking as Non-Monotonic Reasoning: A
Description Logic Approach
Tommaso Di Noia t.dinoia@poliba.it
Eugenio Di Sciascio disciascio@poliba.it
SisInfLab - Politecnico di Bari, Bari, Italy
Francesco M. Donini donini@unitus.it
Universita` della Tuscia, Viterbo, Italy
Abstract
Matchmaking arises when supply and demand meet in an electronic marketplace, or
when agents search for a web service to perform some task, or even when recruiting agencies
match curricula and job proﬁles. In such open environments, the objective of a matchmak-
ing process is to discover best available oﬀers to a given request.
We address the problem of matchmaking from a knowledge representation perspective,
with a formalization based on Description Logics. We devise Concept Abduction and Con-
cept Contraction as non-monotonic inferences in Description Logics suitable for modeling
matchmaking in a logical framework, and prove some related complexity results. We also
present reasonable algorithms for semantic matchmaking based on the devised inferences,
and prove that they obey to some commonsense properties.
Finally, we report on the implementation of the proposed matchmaking framework,
which has been used both as a mediator in e-marketplaces and for semantic web services
discovery.
1. Introduction
The promise of the Semantic Web initiative is to revolutionize the way information is coded,
stored, and searched on the Internet (Berners-Lee, Hendler, & Lassila, 2001). The basic
idea is to structure information with the aid of markup languages, based on the XML
language, such as RDF and RDFS1, and OWL2. These languages have been conceived
for the representation of machine-understandable, and unambiguous, description of web
content through the creation of domain ontologies, and aim at increasing openness and
interoperability in the web environment.
Widespread availability of resources and services enables—among other advantages—
the interaction with a number of potential counterparts. The bottleneck is that it is diﬃcult
ﬁnding matches, possibly the best ones, between parties.
The need for a matchmaking process arises when supply and demand have to meet in a
marketplace, or when web services able to perform some task have to be discovered, but also
when recruiting agencies match curricula and job proﬁles or a dating agency has to propose
partners to a customer of the agency. Requests and oﬀers may hence be generic demands
and supplies, web services, information, tangible or intangible goods, and a matchmaking
process should ﬁnd for any request an appropriate response. In this paper we concentrate
1. http://www.w3.org/RDF/
2. http://www.w3.org/TR/owl-features/
c©2007 AI Access Foundation. All rights reserved.
Di Noia, Di Sciascio & Donini
on automated matchmaking, basically oriented to electronic marketplaces and service dis-
covery, although principles and algorithms are deﬁnitely general enough to cover also other
scenarios. We assume, as it is reasonable, that both requests and oﬀers are endowed of
some kind of description. Based on these descriptions the target of the matching process
is ﬁnding, for a given request, best matches available in the oﬀers set, and also, given an
oﬀer, determine best matching requests in a peer-to-peer fashion. We may hence think of an
electronic mediator as the actor who actively tries to carry out the matchmaking process.
Obviously descriptions might be provided using unstructured text, and in this case such an
automated mediator should revert to adopting either basic string matching techniques or
more sophisticated Information Retrieval techniques.
The Semantic Web paradigm calls for descriptions that should be provided in a struc-
tured form based on ontologies, and we will assume in what follows that requests and oﬀers
are given with reference to a common ontology. It should be noticed that even when requests
and oﬀers are described in heterogeneous languages, or using diﬀerent ontologies modelling
the same domain, schema/data integration techniques may be employed to make them
comparable, as proposed e.g., by Madhavan, Bernstein, and Rahm (2001), and Shvaiko and
Euzenat (2005); but once they are reformulated in a comparable way, one is still left with
the basic matchmaking problems: given a request, are there compatible oﬀers? If there are
several compatible oﬀers, which, and why, are the most promising ones?
Matchmaking has been widely studied and several proposals have been made in the past;
we report on them in Section 2. Recently, there has been a growing eﬀort aimed at the
formalization with Description Logics (DLs) (Baader, Calvanese, Mc Guinness, Nardi, &
Patel-Schneider, 2003) of the matchmaking process (e.g., Di Sciascio, Donini, Mongiello, &
Piscitelli, 2001; Trastour, Bartolini, & Priest, 2002; Sycara, Widoﬀ, Klusch, & Lu, 2002; Di
Noia, Di Sciascio, Donini, & Mongiello, 2003b; Li & Horrocks, 2003; Di Noia, Di Sciascio,
Donini, & Mongiello, 2003c, 2003a, among others). DLs, in fact, allow to model structured
descriptions of requests and oﬀers as concepts, usually sharing a common ontology. Fur-
thermore DLs allow for an open-world assumption. Incomplete information is admitted,
and absence of information can be distinguished from negative information. We provide a
little insight on DLs in Section 3.
Usually, DL-based approaches exploit standard reasoning services of a DL system—
subsumption and (un)satisﬁability—to match potential partners in an electronic transac-
tion. In brief, if a supply is described by a concept Sup and a demand by a concept Dem,
unsatisﬁability of the conjunction of Sup and Dem (noted as Sup Dem) identiﬁes the in-
compatible proposals, satisﬁability identiﬁes potential partners—that still have to agree on
underspeciﬁed constraints—and subsumption between Sup and Dem (noted as Sup  Dem)
means that requirements on Dem are completely fulﬁlled by Sup.
Classiﬁcation into compatible and incompatible matches can be useless in the presence of
several compatible supplies; some way to rank most promising ones has to be identiﬁed; also
some explanation on motivation of such a rank could be appreciated. On the other hand,
when there is lack of compatible matches one may accept to turn to incompatible matches
that could still be interesting, by revising some of the original requirements presented in
the request, as far as one could easily identify them.
In other words some method is needed to provide a logic-based score for both compatible
and incompatible matches and eventually provide a partial/full ordering, allowing a user
270
Semantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach
or an automated agent to choose most promising counteroﬀers. Furthermore it should be
possible, given a score, to provide logical explanations of the resulting score, thus allowing
to understand the rank result and ease further interaction to reﬁne/revise the request.
Although this process is quite simple for a human being it is not so in a logic-based fully
automated framework. We believe there is a need to deﬁne non-monotonic reasoning services
in a DLs setting, to deal with approximation and ranking, and in this paper we propose
the use of Concept Abduction (Di Noia et al., 2003a) and Concept Contraction (Colucci,
Di Noia, Di Sciascio, Donini, & Mongiello, 2003), as services amenable to answer the above
highlighted issues in a satisfactory way. Contributions of this paper include:
• a logical framework to express requests and oﬀers in terms of concept descriptions,
and properties that should hold in a matchmaking facilitator;
• Concept Abduction as a logical basis for ranking compatible counteroﬀers to a given
oﬀer and provide logical explanations of the ranking result;
• Concept Contraction as a logical basis for ranking incompatible matches, aimed at
discovering most promising “near misses”, and provide logical explanations of the
ranking result;
• algorithms implementing the formalized inferences for matchmaking purposes and
complexity results for a class of matchmaking problems;
• description of our system implementing semantic matchmaking services, and experi-
mental evaluation.
The remaining of the paper is structured as follows: next Section reports on background
work on the subject. Then (Section 3) we brieﬂy revise Description Logics basics. To make
the paper self-contained we recall (Section 4) our logic-based framework for matchmaking,
pointing out properties that matchmaking algorithms and systems should guarantee. In
Sections 5 and 6 we present Concept Abduction and Concept Contraction, the two inference
services we devised to compute semantic matchmaking, and present suitable deﬁnitions
of the problem along with some complexity results. Then in Section 7 we describe our
matchmaker, and present (Section 7.1) an evaluation of results computed by the system
compared with human users behavior, and with a standard full text retrieval approach.
Conclusions close the paper.
2. Related Work on Matchmaking
Matchmaking has been investigated in recent years under a number of perspectives and for
diﬀerent purposes, with a renovated interest as the information overload kept growing with
the Web widespreading use. We try here to summarize some of the relevant related work.
Vague query answering, proposed by Motro (1988), was an initial eﬀort to overcome limi-
tations of relational databases, using weights attributed to several search variables. More
recent approaches along these lines aim at extending SQL with ”preference” clauses, in
order to softly matchmake data in structured databases (Kießling, 2002). Finin, Fritzson,
McKay, and McEntire (1994) proposed KQML as an agent communication language ori-
ented to matchmaking purposes. Kuokka and Harada (1996) investigated matchmaking
271
Di Noia, Di Sciascio & Donini
as a process that allowed potential producers/consumers to provide descriptions of their
products/needs, either directly or through agents mediation, to be later uniﬁed by an en-
gine identifying promising matches. Two engines were developed, the SHADE system,
which again used KQML, and as description language KIF, with matchmaking anyway not
relying on any logical reasoning, and COINS, which adopted classical unstructured-text in-
formation retrieval techniques, namely the SMART IR system. Similar methods were later
re-considered in the GRAPPA system (Veit, Muller, Schneider, & Fiehn, 2001). Classiﬁed-
ads matchmaking, at a syntactic level, was proposed by Raman, Livny, and Solomon (1998)
to matchmake semi-structured descriptions advertising computational resources in a fashion
anticipating Grid resources brokering. Matchmaking was used in SIMS (Arens, Knoblock,
& Shen, 1996) to dynamically integrate queries; the approach used KQML, and LOOM
as description language. LOOM is also used in the subsumption matching addressed by
Gil and Ramachandran (2001). InfoSleuth (Jacobs & Shea, 1995), a system for discovery
and integration of information, included an agent matchmaker, which adopted KIF and
the deductive database language LDL++. Constraint-based approaches to matchmaking
have been proposed and implemented in several systems, e.g., PersonaLogic3, Kasbah4 and
systems by Maes, Guttman, and Moukas (1999), Karacapilidis and Moraitis (2001), Wang,
Liao, and Liao (2002), Stro¨bel and Stolze (2002).
Matchmaking as satisﬁability of concept conjunction in DLs was ﬁrst proposed in the
same venue by Gonzales-Castillo, Trastour, and Bartolini (2001) and by Di Sciascio et al.
(2001), and precisely deﬁned by Trastour et al. (2002). Sycara, Paolucci, Van Velsen, and
Giampapa (2003) introduced a speciﬁc language for agent advertisement in the framework
of the Retsina Multiagent infrastructure. A matchmaking engine was developed (Sycara
et al., 2002; Paolucci, Kawamura, Payne, & Sycara, 2002), which carries out the process on
ﬁve possible levels. Such levels exploit both classical text-retrieval techniques and semantic
match using Θ-subsumption. Nevertheless, standard features of a semantic-based system,
as satisﬁability check are unavailable. It is noteworthy that in this approach, the notion
of plug-in match is introduced, to overcome in some way the limitations of a matching ap-
proach based on exact matches. The approach of Paolucci et al. (2002) was later extended
by Li and Horrocks (2003), where two new levels for matching classiﬁcation were introduced.
A similar classiﬁcation was proposed—in the same venue—by Di Noia et al. (2003c), along
with properties that a matchmaker should have in a DL-based framework, and algorithms to
classify and semantically rank matches within classes. Benatallah, Hacid, Rey, and Toumani
(2003) proposed the Diﬀerence Operator in DLs for semantic matchmaking. The approach
uses Concept Diﬀerence, followed by a covering operation optimized using hypergraph tech-
niques, in the framework of web services discovery. We brieﬂy comment on the relationship
between Concept Diﬀerence and Concept Abduction at the end of Section 5. An initial DL-
based approach, adopting penalty functions ranking, has been proposed by Cal`ı, Calvanese,
Colucci, Di Noia, and Donini (2004), in the framework of dating systems. An extended
matchmaking approach, with negotiable and strict constraints in a DL framework has been
proposed by Colucci, Di Noia, Di Sciascio, Donini, and Mongiello (2005), using both Con-
cept Contraction and Concept Abduction. Matchmaking in DLs with locally-closed world
3. http://www.PersonaLogic.com
4. http://www.kasbah.com
272
Semantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach
assumption applying autoepistemic DLs has been proposed by Grimm, Motik, and Preist
(2006).
The need to work in someway with approximation and ranking in DL-based approaches
to matchmaking has also recently led to adopting fuzzy-DLs, as in Smart (Agarwal &
Lamparter, 2005) or hybrid approaches, as in the OWLS-MX matchmaker (Klusch, Fries,
Khalid, & Sycara, 2005). Such approaches, anyway, relaxing the logical constraints, do not
allow any explanation or automated revision service.
Finally, it should be pointed out that matching in DLs, widely treated by Baader,
Ku¨sters, Borgida, and Mc Guinness (1999) has no relation to matchmaking. In fact, in that
work expressions denoting concepts are considered, with variables in expressions. Then
a match is a substitution of variables with expressions that makes a concept expression
equivalent to another. Also the more general setting of concept rewriting in DLs has no
direct relation with matchmaking—see the discussion in Remark 1.
3. Description Logics Basics
In this Section we summarize the basic notions and deﬁnitions about Description Logics
(DLs), and about Classic, the knowledge representation system our application is inspired
by. We provide hereafter a brief guided-tour of DLs main characteristics, while the interested
reader can refer to the comprehensive handbook by Baader et al. (2003).
3.1 Description Logics
Description Logics—a.k.a. Terminological Logics—are a family of logic formalisms for Knowl-
edge Representation. All DLs are endowed of a syntax, and a semantics, which is usually
model-theoretic. The basic syntax elements of DLs are:
• concept names, e.g., Computer, CPU, Device, Software,
• role names, like hasSoftware, hasDevice
• individuals, that are used for special named elements belonging to concepts.
Intuitively, concepts stand for sets of objects, and roles link objects in diﬀerent concepts,
as the role hasSoftware that links computers to software. We are not using individuals in
our formalization, hence from now on we skip the parts regarding individuals.
Formally, a semantic interpretation is a pair I = (Δ, ·I), which consists of the domain
Δ and the interpretation function ·I , which maps every concept to a subset of Δ, and every
role to a subset of Δ×Δ.
Basic elements can be combined using constructors to form concept and role expressions,
and each DL has its distinguished set of constructors. Every DL allows one to form a
conjunction of concepts, usually denoted as ; some DL include also disjunction unionsq and
complement ¬ to close concept expressions under boolean operations.
Roles can be combined with concepts using
• existential role quantiﬁcation:
e.g., Computer  ∃hasSoftware.WordProcessor
which describes the set of computers whose software include a word processor, and
273
Di Noia, Di Sciascio & Donini
• universal role quantiﬁcation
e.g., Server  ∀hasCPU.Intel
which describes servers with only Intel processors on board.
Other constructs may involve counting, as
• number restrictions:
e.g., Computer  (≤ 1 hasCPU)
expresses computers with at most one CPU, and
e.g., Computer  (≥ 4 hasCPU)
describes computers equipped with at least four CPUs.
Many other constructs can be deﬁned, increasing the expressive power of the DL, up to
n-ary relations (Calvanese, De Giacomo, & Lenzerini, 1998).
In what follows, we call atomic concepts the union of concept names, negated concept
names, and unqualiﬁed number restrictions. We deﬁne length of a concept C as the number
of atomic concepts appearing in C. We denote the length of C as |C|. Observe that we
consider 	 and ⊥ to have zero length. We deﬁne the Quantiﬁcation Nesting (QN) of a
concept as the following positive integer: the QN of an atomic concept is 0, the QN of a
universal role quantiﬁcation ∀R.F is 1 plus the QN of F , and the QN of a conjunction
C1 C2 is the maximum between the QNs of conjoined concepts C1 and C2.
Expressions are given a semantics by deﬁning the interpretation function over each
construct. For example, concept conjunction is interpreted as set intersection: (C D)I =
CI ∩DI, and also the other boolean connectives unionsq and ¬, when present, are given the usual
set-theoretic interpretation of union and complement. The interpretation of constructs
involving quantiﬁcation on roles needs to make domain elements explicit: for example,
(∀R.C)I = {d1 ∈ Δ | ∀d2 ∈ Δ : (d1, d2) ∈ RI → d2 ∈ CI}
3.2 TBoxes
Concept expressions can be used in axioms—that can be either inclusions (symbol: ), or
deﬁnitions (symbol: ≡)—which impose restrictions on possible interpretations according
to the knowledge elicited for a given domain. For example, we could impose that monitors
can be divided into CRT and LCD using the two inclusions: Monitor  LCDMonitor unionsq
CRTMonitor and CRTMonitor  ¬LCDMonitor. Or, that computers for a domestic use have
only one operating system as HomePC  (≤ 1 hasOS). Deﬁnitions are useful to give a
meaningful name to particular combinations, as in Server ≡ Computer  (≥ 2 hasCPU).
Historically, sets of such axioms are called a TBox (Terminological Box). There are
several possible types of TBoxes. General TBoxes are made by General Concept Inclusions
(GCI) of the form C  D, where both C and Dem can be any concept of the DL. For
general TBoxes, the distinction between inclusions and deﬁnitions disappears, since any
deﬁnition C ≡ D can be expressed by two GCIs C  D,D  C. On the contrary, in
simple TBoxes—also called schemas by Calvanese (1996), and by Buchheit, Donini, Nutt,
and Schaerf (1998)—only a concept name can appear on the left-hand side (l.h.s.) of an
axiom, and a concept name can appear on the l.h.s. of at most one axiom. Schemas can be
274
Semantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach
cyclic or acyclic, where cyclicity refers to the dependency graph GT between concept names,
deﬁned as follows: every concept name is a node in GT , and there is an arc from concept
name A to concept name B if A appears on the l.h.s. of an axiom, and B appears (at any
level) in the concept on the right-hand side. T is acyclic if GT is, and it is cyclic otherwise.
We call an acyclic schema a simple TBox (Baader et al., 2003, Ch.2). The depth of a simple
TBox T is the length of the longest path in GT . Only for simple TBoxes, unfolding has
been deﬁned as the following process (see Appendix A for a deﬁnition): for every deﬁnition
A ≡ C, replace A with C in every concept; for every inclusion A  C, replace A with AC
in every concept. Clearly, such a process trasforms every concept into an equivalent one,
where the TBox can be forgotten. However, for some TBoxes, unfolding can yield concepts
of exponential size w.r.t. the initial concepts. When such an exponential blow-up does not
happen, we call the TBox “bushy but not deep” (Nebel, 1990).
The semantics of axioms is based on set containment and equality: an interpretation I
satisﬁes an inclusion C  D if CI ⊆ DI , and it satisﬁes a deﬁnition C ≡ D when CI = DI .
A model of a TBox T is an interpretation satisfying all axioms of T .
Observe that we make a distinction between equivalence ≡ (used in axioms) and equality
= symbols. We use equality to instantiate generic concept symbols with the concepts they
stand for, e.g., when we write “... where C = A  ∀R.B...” we mean that the concept
symbol C stands for the concept expression A  ∀R.B in the text.
3.3 Reasoning Services
DL-based systems usually provide two basic reasoning services:
1. Concept Satisﬁability : given a TBox T and a concept C, does there exist at least one
model of T assigning a non-empty extension to C? We abbreviate satisﬁability of a
concept C w.r.t. a TBox T as C T ⊥.
2. Subsumption: given a TBox T and two concepts C and D, is CI always contained in
DI for every model Iof T ? We abbreviate subsumption between C and D w.r.t. T
as C T D.
Since C is satisﬁable iﬀ C is not subsumed by ⊥, complexity lower bounds for satisﬁability
carry over (for the complement class) to subsumption, and upper bounds for subsumption
carry over to satisﬁability. On the other hand, since C is subsumed by D iﬀ C  ¬D is
unsatisﬁable, subsumption is reducible to satisﬁability in DLs admitting general concept
negation, but not in those DLs in which ¬D is outside the language—as in the DLs of the
next Section.
3.4 The System Classic
The system Classic (Borgida, Brachman, McGuinness, & A. Resnick, 1989; Borgida &
Patel-Schneider, 1994) has been originally developed as a general Knowledge Representation
system, and has been successfully applied to conﬁguration (Wright, Weixelbaum, Vesonder,
Brown, Palmer, Berman, & Moore, 1993) and program repositories management (Devambu,
Brachman, Selfridge, & Ballard, 1991).
Its language has been designed to be as expressive as possible while still admitting
polynomial-time inferences for “bushy but not deep” TBoxes. So it provides intersection of
275
Di Noia, Di Sciascio & Donini
name concrete syntax syntax semantics
top TOP 	 ΔI
bottom - ⊥ ∅
intersection (and C D) C D CI ∩DI
universal
quantiﬁcation
(all R C) ∀R.C {d1 | ∀d2 : (d1, d2) ∈ RI → d2 ∈ CI}
number (at-least n R) (≥ n R) {d1 | {d2 | (d1, d2) ∈ RI} ≥ n}
restrictions (at-most n R) (≤ n R) {d1 | {d2 | (d1, d2) ∈ RI} ≤ n}
Table 1: Syntax and semantics of some constructs of Classic
name system notation syntax semantics
deﬁnition (createConcept A C false) A ≡ C AI = CI
inclusion (createConcept A C true) A  C AI ⊆ CI
disjoint
group
(createConcept A1 C symbol)
. . .
(createConcept Ak C symbol)
disj(A1, . . . ,Ak)
for i = 1, . . . , k AIi ⊆ CI
and for j = i + 1, . . . , k
AIi ∩AIj = ∅
Table 2: Syntax and semantics of the TBox Classic assertions (symbol is a name denoting
the group of disjoint concepts)
concepts but no union, universal but not existential quantiﬁcation over roles, and number
restrictions over roles but no intersection of roles, since each of these combinations is known
to make reasoning np-hard (Donini, Lenzerini, Nardi, & Nutt, 1991; Donini, 2003).
For simplicity, we only consider a subset of the constructs, namely, conjunction, number
restrictions, and universal role quantiﬁcations, summarized in Table 1. We abbreviate the
conjunction (≥ n R)  (≤ n R) as (= n R). We omit constructs ONE-OF(·), FILLS(·,·)
that refer to individuals, and construct SAME-AS(·,·) equating ﬁllers in functional roles.
The subset of Classic we refer to is known as ALN (Attributive Language with unqualiﬁed
Number restrictions) (Donini, Lenzerini, Nardi, & Nutt, 1997b). When number restrictions
are not present, the resulting DL is known as AL (Schmidt-Schauß & Smolka, 1991). ALN
provides a minimal set of constructs that allow one to represent a concept taxonomy, disjoint
groups, role restrictions (AL), and number restrictions (N ) to represent restriction son the
number of ﬁllers of a role.
Regarding axioms in a TBox, Classic allows one to state a simple TBox of assertions
of the form summarized in Table 2, where A,A1, . . . ,Ak are all concept names. Axioms
in the TBox are subject to the constraints that every concept name can appear at most
once as the l.h.s. in a TBox, and every concept name cannot appear both on the l.h.s. of a
deﬁnition and in a disjointness assertion.
Every Classic concept can be given a normal form. Here we consider the normal form
only for the constructs of ALN that we used in the ontologies and applications. Intuitively,
the normal form pre-computes all implications of a concept, including—possibly—its un-
satisﬁability. The normal form can be reached, up to commutativity of the operator ,
using well-known normalization rules, that we report in Appendix A to make the paper
276
Semantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach
self-contained. The normal form of an unsatisﬁable concept is simply ⊥. Every satisﬁable
concept C can be divided into three components: CnamesCCall. The component Cnames
is the conjunction of all concept names A1, . . . ,Ah. The component C is the conjunction
of all number restrictions, no more than two for every role (the maximum at-least and the
minimum at-most for each role), including for every conjunct of C of the form ∀R.⊥, the
number restriction (≤ 0 R) in C. The component Call conjoins all concepts of the form
∀R.D, one for each role R, where D is again in normal form. We call such form Conjunc-
tive Normal Form—CNF, in analogy with Propositional Logic—and we observe that CNF
is unique (also said canonical), up to commutativity of conjunction.
Moreover, the TBox in Classic can be embedded into the concepts, by expanding
deﬁnitions, and adding the right-hand-side concepts of inclusions, and adding the negation
of disjoint concept names—see Appendix A for more details. For instance, suppose that a
TBox contains:
1. the deﬁnition Server ≡ Computer  (≥ 2 hasCPU),
2. the inclusion Computer  (≥ 1 hasStorageDevice),
3. and the disjointness assertion disj(AMD, Intel).
Then, the concept Server∀hasCPU.Intel can be rewritten into Computer(≥ 2 hasCPU)
(≥ 1 hasStorageDevice)∀hasCPU.(Intel¬AMD), which is equivalent to the former w.r.t.
models of the TBox. Observe that the concept name Computer is kept in the rewriting,
since the inclusion gives only a necessary condition (≥ 1 hasStorageDevice). The latter
concept can be safely conjoined to Computer–making the inclusion unnecessary—but can-
not replace it since (≥ 1 hasStorageDevice) is not a suﬃcient condition for Computer.
Instead, Computer  (≥ 2 hasCPU) replaces Server since it is a necessary and suﬃcient
condition for it. The disjoint assertion generates Intel  ¬AMD as the range for ∀hasCPU..
Once this rewriting has been carried over all concepts, the TBox can be safely ignored when
computing subsumption (and satisﬁability). In general, this unfolding may lead to an expo-
nential blow-up of the TBox, making the entire computation (unfolding+subsumption) take
exponential time (and space) in the size of the initial concepts and TBox. Yet exponential-
time computation for subsumption is likely to be unavoidable, since even without rewriting,
taking the TBox into account makes subsumption np-hard (Nebel, 1990).
The normal form of concepts can take the TBox embedding into account (see Appen-
dix A.2). In this case, the component Cnames of a Classic concept C contains concept
names Cnames+ and negations of concept names Cnames¬. In the following, we denote the
CNF of a concept C w.r.t. a simple TBox T as CNF (C,T ). Again, in general, the size
of CNF (C,T ) may be exponential w.r.t. the size of C and T . However, when T is ﬁxed,
CNF (C,T ) has polynomial-size w.r.t. the size of C i.e., the exponential increase comes only
from the TBox unfolding. In fact, if k is the maximum size of an unfolded concept name
(a constant if T is ﬁxed), the size of CNF (C,T ) can be at most k times the size of C. We
use this argument later in the paper, to decouple the complexity analysis of our reasoning
methods for matchmaking from the complexity raised by the TBox.
To ease presentation of what follows in the next Sections, we adopt a simple reference
ontology, pictured in Figure 1, which is used throughout the paper. To keep the represen-
tation within ALN , we modeled memory quantities with number restriction, e.g., 20GB as
277
Di Noia, Di Sciascio & Donini
CRTmonitor
LCDmonitor
}
=⊥
 Monitor
DVDRecorder
FloppyDisk
HardDisk
⎫⎪⎬
⎪⎭  StorageDevice
⎫⎪⎪⎪⎪⎪⎪⎪⎬
⎪⎪⎪⎪⎪⎪⎪⎪⎭
 Device
Linux
Solaris
Windows2000
WindowsXp
⎫⎪⎪⎪⎬
⎪⎪⎪⎭
 OperatingSystem
Browser
WordProcessor
⎫⎪⎪⎪⎪⎪⎪⎬
⎪⎪⎪⎪⎪⎪⎪⎭
 Software
PDA
PC
}
=⊥
 Computer
Computer  (≥ 1 hasStorageDevice)  ∀hasStorageDevice.StorageDevice
∀hasSoftware.Software  (≥ 1 ram)
HomePC  PC  (≥ 1 hasSoftware) 
(= 1 hasOS)  (≥ 1 hasMonitor)  ∀hasMonitor.Monitor
Server  Computer  (≥ 2 hasCPU) 
∀ram.(≥ 512 mb)  ∀hasStorageDevice.(≥ 20000 mb)
Figure 1: Reference Ontology used for examples
(≥ 20000 mb). For reasoners specialized for ALN , this is not a problem, since a number n
is never expanded as n ﬁllers (Borgida & Patel-Schneider, 1994; Donini et al., 1997b). For
more expressive DLs, Concrete Domains (Lutz, 1999) should be employed to represent such
quantities.
4. Semantic Matchmaking Using Description Logics
Matchmaking is a widely used term in a variety of frameworks, comprising several—quite
diﬀerent—approaches. We begin this Section trying to provide a generic and sound deﬁni-
tion of matchmaking.
Matchmaking is an information retrieval task whereby queries (a.k.a. de-
mands) and resources (a.k.a. supplies) are expressed using semi-structured data
in the form of advertisements, and task results are ordered (ranked) lists of those
resources best fulﬁlling the query.
This simple deﬁnition implies that—diﬀerently from classical unstructured-text Information
Retrieval systems—some structure in the advertisements is expected in a matchmaking
278
Semantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach
system, and matchmaking does not consider a ﬁxed database-oriented relational structure.
Furthermore, usually database systems provide answers to queries that do not include a
relevance ranking, which should be instead considered in a matchmaking process.
Semantic matchmaking is a matchmaking task whereby queries and resources
advertisements are expressed with reference to a shared speciﬁcation of a con-
ceptualization for the knowledge domain at hand, i.e., an ontology.
From now on, we concentrate on semantic matchmaking in marketplaces, adopting speciﬁc
terminology, to ease presentation of the approach. Nevertheless our approach applies to
generic matchmaking of semantically annotated resources.
We note that all deﬁnitions in this Section apply to every DL that can be used to
describe a marketplace (supplies, demands, background knowledge). We denote by L such
a generic DL. We suppose that a common ontology for supplies and demands is established,
as a TBox T in L. Now a match between a supply and a demand could be evaluated
according to T .
First of all, we remark that a logic-based representation of supplies and demands calls
for generally Open-world descriptions, that is, the absence of a characteristic in the descrip-
tion of a supply or demand should not be interpreted as a constraint of absence. Instead,
it should be considered as a characteristic that could be either reﬁned later, or left open
if it is irrelevant for a user. Note that by “generally open” we mean that some speciﬁc
characteristic might be declared to be closed. However, such a closure should be made
piecewise, using some known declarative tool devised in Knowledge Representation for non-
monotonic reasoning, such as Defaults in DLs (Baader & Hollunder, 1992), Autoepistemic
DLs (Donini, Nardi, & Rosati, 1997a), Circumscription in DLs (Bonatti, Lutz, & Wolter,
2006) etc.
An analysis of recent literature allows to categorize the semantic matchmaking process
between a supply Sup and a demand Dem w.r.t. a TBox T in ﬁve distinct classes:
• exact match: Sup ≡T Dem, i.e., Sup T Dem and Dem T Sup, which amounts
to a perfect match, regardless—in a semantic based environment—of syntactic diﬀer-
ences, i.e., Sup and Dem are equivalent concepts (Di Sciascio et al., 2001; Gonzales-
Castillo et al., 2001).
• full match: Sup T Dem, which amounts to the demand being completely fulﬁlled
by the available supply, i.e., Sup has at least all features required by Dem, but not
necessarily vice versa, being the matchmaking process not symmetric (Di Noia et al.,
2003c); this kind of match is also named subsume match by Li and Horrocks (2003).
• plug-in match: Dem T Sup; it corresponds to demand Dem being sub-concept of
supply Sup,i.e., Dem is more speciﬁc than Sup (Sycara et al., 2002; Li & Horrocks,
2003).
• potential match: DemSup T ⊥, which corresponds to supply and demand having
something in common and no conﬂicting characteristics (Di Noia et al., 2003c). This
relation is also named intersection-satisﬁable by Li and Horrocks (2003).
279
Di Noia, Di Sciascio & Donini
• partial match: DemSup T ⊥, which amounts to the presence of conﬂict between
the demand and the available supply (Di Noia et al., 2003c). This relation is also
named disjoint by Li and Horrocks (2003)5.
We stress that demands could be classiﬁed in the same way w.r.t. a given supply, when
it’s the supplier’s turn to look into the marketplace to ﬁnd potential buyers. Hence, in the
rest of the paper we use the term oﬀer—denoted by the symbol D—to mean either a supply
Sup or a demand Dem, and the term counteroﬀer—denoted by C—to mean, respectively,
the demand Dem or the supply Sup that could match D.
Such a classiﬁcation is still a coarse one, relying directly on known logical relations
between formulae. In fact, the result of matchmaking should be a rank of counteroﬀers,
according to some criteria—possibly explicit—so that a user trusting the system would
know whom to contact ﬁrst, and in case of failure, whom next, and so on. Such a ranking
process should satisfy some criteria that a Knowledge Representation approach suggests.
We formulate ranking requirements by referring to properties of penalty functions.
Deﬁnition 1 Given a DL L, two concepts C,D ∈ L, and a TBox T in L, a penalty
function is a three-arguments function p(C,D,T ), that returns a null or positive integer.
We use penalty functions to rank counteroﬀers C for a given demand (or supply) D w.r.t. a
TBox T . Intuitively, for two given counteroﬀers C1, C2 in the marketplace, if p(C1,D,T ) <
p(C2,D,T ) then the issuer of oﬀer D should rank C1 better than C2 when deciding whom to
contact ﬁrst. Clearly, a 0-penalty should be ranked best, and counteroﬀers with the same
penalties should be ranked breaking ties. The ﬁrst property we recall is Non-symmetric
evaluation of proposals.
Deﬁnition 2 A penalty function p(·, ·, ·) is non-symmetric if there exist concepts C,D and
a TBox T such that p(C,D,T ) = p(D,C,T ).
This property is evident when all constraints of D are fulﬁlled by C but not vice versa.
Hence, C should be among the top-ranked counteroﬀers in the list of potential partners of
D, while D should not necessarily appear at the top in the list of potential partners of C.
So, a penalty function p(·, ·, ·) should not be expected to be a metric distance function.
Secondly, if logic is used to give some meaning to descriptions of supplies and demands,
then proposals with the same meaning should be equally penalized, independently of their
syntactic descriptions.
Deﬁnition 3 A penalty function p(·, ·, ·) is syntax independent if for every triple of con-
cepts C1, C2,D, and TBox T , when T |= C1 ≡ C2 then p(C1,D,T ) = p(C2,D,T ), and the
same holds also for the second argument , i.e., p(D,C1,T ) = p(D,C2,T )
5. We note that preferring the term “partial match” instead of “disjoint”, we stress that the match may
still be recoverable, while disjoint is usually meant as a hopeless situation. Moreover, “disjoint” and
“intersection satisﬁable” refer to the set-theoretic semantics of concepts in Description Logics, which
is quite hidden and far from the original problems of matchmaking. In a word, they are technology-
oriented and not problem-oriented. For instance, if one used Propositional Logic, or Three-valued Logic
for modeling matchmaking, those terms would make no sense.
280
Semantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach
Clearly, when the logic admits a normal form of expressions—as CNF or DNF for propo-
sitional logic, or the normal form of concepts for DLs deﬁned in the previous Section—using
such a normal form in the computation of p(·, ·, ·) ensures by itself syntax independence.
Penalties should enjoy some desirable properties w.r.t. subsumption. For reasons ex-
plained below, we divide penalty functions for ranking potential matches from those for
ranking partial (conﬂicting) matches.
Deﬁnition 4 A penalty function for potential matches is monotonic over subsumption
whenever for every issued oﬀer D, for every pair of counteroﬀers C1 and C2, and TBox T ,
if C1 and C2 are both potential matches for D w.r.t. T , and (C1 T C2), then p(C1,D,T ) ≤
p(C2,D,T )
Intuitively, the above deﬁnition could be read of as: if C1 T C2 then C1 should be penalized
(and then ranked) either the same, or better than C2. In a phrase, A ranking of potential
matches is monotonic over subsumption if more speciﬁc means better. A dual property
could be stated for the second argument: if D1 T D2 then a counteroﬀer C is less likely to
fulﬁll all characteristics required by D1 than D2. However, since our scenario is: “given an
issuer of a proposal D looking for a match in the marketplace, rank all possible counteroﬀers
C1, C2, . . . , from the best one to the worst”, we do not deal here with this duality between
ﬁrst and second argument of p(·, ·, ·).
When turning to partial matches, in which some properties are already in conﬂict be-
tween supply and demand, the picture reverses. Now, adding another characteristic to an
unsatisfactory proposal may only worsen this ranking (when another characteristic is vio-
lated) or keep it the same (when the new characteristic is not in conﬂict). Note that this
ranking should be kept diﬀerent from the ranking for potential matches. After all, accepting
to discard one or more characteristics that we required is much worse than deciding which
proposal try ﬁrst among some potential ones.
Deﬁnition 5 A penalty function for partial matches is antimonotonic over subsumption
whenever for every issued oﬀer D, for every pair of counteroﬀers C1 and C2, and TBox T ,
if C1 and C2 are both partial matches for D w.r.t. T , and (C1 T C2), then p(C1,D,T ) ≥
p(C2,D,T )
Intuitively, if C1 T C2 then C1 should be penalized (and then ranked) either the same,
or worse than C2. In other words, A ranking of partial matches is antimonotonic over
subsumption if more speciﬁc means worse. The same property should hold also for the
second argument, since concept conjunction is commutative.
When we need to distinguish between a penalty function for potential matches and one
for partial matches, we put a subscript  in the former (as p) and a subscript ⊥ for the
latter (as in q⊥).
Clearly, the above requirements are very general, and leave ample room for the deﬁnition
of penalty functions. A more subtle requirement would be that penalties should not change
when irrelevant details are added, e.g., if a second-hand computer is requested in a demand
Dem, with no speciﬁcation for the brand of the CPU, then a supply Sup should be penalized
the same as another oﬀer Sup∀hasCPU.Intel. However, instead of delving into irrelevance
and other logic-related issues directly from penalties, we now borrow well-known logical
281
Di Noia, Di Sciascio & Donini
reasoning frameworks in propositional knowledge representation. Such a detour will give us
a sound and declarative way of deﬁning penalties, dealing with irrelevance as a byproduct,
and more generally bring well-studied non-standard reasoning techniques into matchmaking.
5. Concept Abduction
Abduction (Peirce, 1955) is a well known form of commonsense reasoning, usually aimed at
ﬁnding an explanation for some given symptoms or manifestations. Here we introduce Con-
cept Abduction in DLs, showing how it can model potential matchmaking in a DL setting.
Following the notation proposed by Eiter and Gottlob (1995), we recall that a Propositional
Abduction Problem is a triple 〈H,M,T 〉 where H (Hypotheses) and M (Manifestations)
are sets of literals, and T (Theory) is a set of formulae. A solution for 〈H,M,T 〉 is an Ex-
planation E ⊆ H such that T ∪E is consistent, and T ∪E |= M . We adapt this framework
to DLs as follows.
Deﬁnition 6 Let L be a DL, C, D, be two concepts in L, and T be a set of axioms in
L, where both C and D are satisﬁable in T . The Concept Abduction Problem (CAP) for
a given 〈L, C,D,T 〉, is ﬁnding, if possible, a concept H ∈ L such that C  H T ⊥, and
C H T D.
We use P as a symbol for a generic CAP, and we denote with SOL(P) the set of all
solutions to a CAP P. Observe that in the deﬁnition, we limit the inputs of a CAP to
satisﬁable concepts C and D, since C unsatisﬁable implies that the CAP has no solution
at all, while D unsatisﬁable leads to counterintuitive results (e.g., ¬C would be a solution
in that case). As Propositional Abduction extends implication, Concept Abduction ex-
tends concept subsumption. But diﬀerently from propositional abduction, we do not make
any distinction between manifestations and hypotheses, which is usual when abduction is
used for diagnosis. In fact, when making hypotheses about e.g., properties of goods in
e-marketplaces, there is no point in making such a distinction. This uniformity implies that
there is always the trivial solution D to a non-trivial CAP 〈L, C,D,T 〉, as stated more
formally as follows.
Proposition 1 Let L be a DL, let C,D be concepts in L, and T an L-TBox. Then CD T
⊥ if and only if D ∈ SOL(〈L, C,D,T 〉).
Proof. If C  D is satisﬁable in T , then D fulﬁlls both requirements of Def. 6, the ﬁrst
one by hypothesis and the second one because C D T D is a tautology. On the other
hand, if D ∈ SOL(〈L, C,D,T 〉) then C D T ⊥ by deﬁnition.
A simple interpretation of this property in our application domain, i.e., matchmaking,
is that if we hypothesize for the counteroﬀer C exactly all speciﬁcations in D, then the
counteroﬀer trivially meets given speciﬁcations—if it was compatible anyway. However, not
all solutions to a CAP are equivalent when using Concept Abduction for matchmaking. To
make a simple example, suppose that already C T D. Then, both H1 = D and H2 = 	
(among others) are solutions of 〈L, C,D,T 〉. Yet, the solution H2 = 	 tells the issuer of
D that C already meets all of D’s speciﬁcations, while the solution H1 = D is the least
282
Semantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach
informative solution from this point of view. Hence, if we want to use abduction to highlight
most promising counteroﬀers, “minimal” hypotheses must be deﬁned.
Deﬁnition 7 Let P =〈L, C,D,T 〉 be a CAP. The set SOL(P) is the subset of SOL(P)
whose concepts are maximal under T . The set SOL≤(P) is the subset of SOL(P) whose
concepts have minimum length.
Clearly, being maximal w.r.t. T is still a minimality criterion, since it means that no
unnecessary hypothesis is assumed. It can be proved that the two measures are incompa-
rable.
Proposition 2 There exists a CAP P such that the two sets SOL(P) and SOL≤(P) are
incomparable.
Proof. It is suﬃcient to consider D = A1A2A3, C = A1, and T = {B  A2A3}. The
logic is even propositional. Then A2 A3 ∈ SOL(〈L, C,D,T 〉), B ∈ SOL≤(〈L, C,D,T 〉),
and neither solution is in the other set.
The proof highlights that, although ≤-minimality could be preferable for conciseness, it
is heavily dependent on T . In fact, for every concept H ∈ SOL(P), it is suﬃcient to add the
axiom A ≡ H to get a ≤-minimal solution A. On the other hand, also T -maximality has
some drawbacks: if concept disjunction unionsq is present in L, then there is a single T -maximal
solution of P, that is equivalent to the disjunction of all solutions in SOL(P)—not a very
useful solution. Making an analogy with Abduction-based Diagnosis (Console, Dupre, &
Torasso, 1991), we could say that the disjunction of all possible explanations is not a very
informative explanation itself—although it is maximal w.r.t. implication. We note that
ﬁnding a ≤-minimal solution is np-hard for a TBox of depth 1, by a simple reduction from
Set Covering (Colucci, Di Noia, Di Sciascio, Donini, & Mongiello, 2004).
Remark 1 It is interesting to analyze whether concept minimal-rewriting techniques—as
deﬁned by Baader, Ku¨sters, and Molitor (2000)—could be employed for computing some
minimal concept abduction, trying to rewrite C D. The answer is deﬁnitely negative for
minimal length abduction: the length-minimal solution B in the proof of Proposition 2
could not be obtained by rewriting C  D = A1  A1  A2  A3. In fact, A1  B is not
an equivalent rewriting of the former concept. Regarding T -maximality the answer is
more indirect. In fact, present rewriting techniques do not keep a subconcept ﬁxed in the
rewriting process. So consider a CAP in which D = A1, C = A2, and T = {B ≡ A1 A2}.
The only equivalent minimal rewriting of C D is then B, in which a solution cannot be
identiﬁed since B cannot be separated into a concept C—the original one—and a concept
H that is a solution of the CAP. It is open whether future extensions of rewriting might
keep a concept ﬁxed, and cope with this problem.
A third minimality criterion is possible for DLs which admit CNF, as for L = ALN .
Deﬁnition 8 Let P =〈L, C,D,T 〉 be a CAP in which L admits CNF, and assume that
concepts in SOL(P) are in CNF. The set SOL(P) is the subset of SOL(P) whose concepts
are minimal conjunctions, i.e., if C ∈ SOL(P) then no sub-conjunction of C (at any level
of nesting) is in SOL(P). We call such solutions irreducible.
283
Di Noia, Di Sciascio & Donini
It turns out that -minimality includes both T -maximality and ≤-minimality.
Proposition 3 For every CAP P in which L admits a CNF, both SOL(P) and SOL≤(P)
are included in SOL(P).
Proof. By contraposition, if a concept H is not -minimal then there is another concept
H ′—a sub-conjunction of H—which is an -minimal solution. But |H ′| < |H|, hence H is
not length-minimal. The same for T -maximality: since every sub-conjunction of a concept
H in CNF subsumes H, if H is not -minimal it is not T -maximal either.
The proof of Proposition 2 can be modiﬁed to show that minimum-length abduced
concepts are not unique: it is suﬃcient to add another axiom B′  A2  A3 to obtain
another minimum-length solution B′. A less obvious result is that also subsumption-
maximal solutions are not unique, at least in non-simple TBoxes: Let P = 〈L, C,D,T 〉
with T = {A2  A3  A1}, C = A3,D = A1. Then both A1 and A2 are T -maximal
solutions.
5.1 Irreducible Solutions in ALN -simple TBoxes
We assume here that the TBox T of a CAP P = 〈L, C,D,T 〉 is always a simple one. Finding
an irreducible solution is easier than ﬁnding a ≤-minimal or a T -maximal solution, since a
greedy approach can be used to minimize the set of conjuncts in the solution. For example,
starting from C  D, we could delete one redundant conjunct at a time (at any level of
role quantiﬁcation nesting) from D, using |D| calls to a subsumption-check procedure.
However, such an algorithm would be interesting only for theoretical purposes. Instead, we
adapt a structural subsumption algorithm (Borgida & Patel-Schneider, 1994) that collects
all concepts H that should be conjoined to C in order for C  H to be subsumed by D.
The algorithm operates on concepts in CNF. In the following algorithm, we abbreviate the
fact that a concept A appears as a conjunct of a concept C with A ∈ C (thus extending the
meaning of ∈ to conjunctions of concepts).
Algorithm ﬁndIrred (P);
input: a CAP P = 〈L, C,D,T 〉, with L =ALN , simple T , C and D in CNF w.r.t. T
output: concept H ∈ SOL(P) (where H = 	 means that C  D)
variables: concept H
begin
H := 	;
0. if D  C T ⊥
return ⊥;
1. for every concept name A in D
1.1 if A ∈ C
then H := H A;
2. for every concept (≥ n R) ∈ D
2.1 such that there is no concept (≥ m R) ∈ C with m ≥ n
H := H  (≥ n R);
3. for every concept (≤ n R) ∈ D
284
Semantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach
3.1 such that there is no concept (≤ m R) ∈ C with m ≤ n
H := H  (≤ n R);
4. for every concept ∀R.E ∈ D
4.1 if there exists ∀R.F ∈ C
4.1.1 then H := H  ∀R.ﬁndIrred (〈ALN , F,E,T 〉);
4.1.2 else H := H  ∀R.E;
/* now H ∈ SOL(P), but it might be reducible */
5. for every concept Hi ∈ H
if H without Hi is in SOL(P)
then delete Hi from H;
6. return H;
end.
Theorem 1 Given a CAP P, if ﬁndIrred (P) returns the concept H, with H ≡ ⊥, then H
is an irreducible solution of P.
Proof. We ﬁrst prove that before Step 5, the computed concept H is in SOL(P), that is,
both C H T ⊥ and C H T D hold. In fact, observe that CNF (D,T )  H, since all
conjuncts of H come from some conjunct of CNF (D,T ). Hence, D T H since CNF (D,T )
is equivalent to D in the models of T . Adding C to both sides of the subsumption yields
CD T CH, and since we assume that CD T ⊥, also CH T ⊥. This proves the
ﬁrst condition for H ∈ SOL(P). Regarding the condition C H T D, suppose it does not
hold: then, at least one conjunct of CNF (D,T ) should not appear in CNF (C H,T ). But
this is not possible by construction, since H contains every conjunct which is in CNF (D,T )
and not in CNF (C,T ). Therefore, we conclude that H ∈ SOL(P). Once we proved that
the H computed before Step 5 is a solution of P, we just note that Step 5 deletes enough
conjuncts to make H an irreducible solution.
The ﬁrst part of algorithm (before Step 5) easily follows well-known structural subsump-
tion algorithms (Borgida & Patel-Schneider, 1994). Step 5 applies a greedy approach, hence
the computed solution, although irreducible, might not be minimal.
We explain the need for the reducibility check in Step 5 with the help of the following
example.
Example 1 Let T = {A1  A2, A3  A4}, and let C = A3, D = A1  A4. Then L is the
propositional part of AL. The normal form for C is C ′ = A3A4, while D′ = A1A2A4.
Then before Step 5 the algorithm computes H = A1  A2, which must still be reduced to
A1. It is worth noticing that H is already subsumption-maximal since H ≡T A1. However,
-minimality is a syntactic property, which requires removal of redundant conjuncts.
As for complexity, we aim at proving that ﬁnding an irreducible solution is not more
complex than subsumption in ALN . A polynomial algorithm (w.r.t. the sizes of C, D
and T ) cannot be expected anyway, since subsumption in AL (the sublanguage of ALN
without Number Restrictions) with a simple T is conp-hard (Nebel, 1990; Calvanese, 1996).
However, Nebel (1990) argues that the unfolding of the TBox is exponential in the depth of
285
Di Noia, Di Sciascio & Donini
the hierarchy T ; if the depth of T grows as O(log |T |) as the size of T increases—a “bushy
but not deep” TBox—then its unfolding is polynomial, and so is the above algorithm.
More generally, suppose that T is ﬁxed : this is not an unrealistic hypothesis for our
marketplace application, since T represents the ontology of the domain, that we do not
expect to vary while supplies and demands enter and exit the marketplace. In that case, we
can analyze the complexity of ﬁndIrred considering only C and D for the size of the input
of the problem.
Theorem 2 Let P = 〈L, C,D,T 〉 be a CAP, with L =ALN , and T a simple TBox. Then
ﬁnding an irreducible solution to P is a problem solvable in time polynomial in the size of
C and D.
We note that the problem of the exponential-size unfolding might be mitigated by Lazy
Unfolding (Horrocks & Tobies, 2000). Using this technique, concept names in the TBox are
unfolded only when needed.
5.2 Abduction-Based Ranking of Potential Matches
We deﬁne a penalty function p for potential matches based on the following intuition: the
ranking of potential matches should depend on how many hypotheses have to be made on
counteroﬀers in order to transform them into full matches.
Deﬁnition 9 Given a simple TBox T in ALN , we deﬁne a penalty function for the po-
tential match of a counteroﬀer C given an oﬀer D, where both C and D are concepts in
ALN , as follows:
p(C,D,T ) .= |ﬁndIrred (〈ALN ,CNF (C,T ),CNF (D,T ), ∅〉)| (1)
Note that, when computing p, a concept H is actually computed by ﬁndIrred as an
intermediate step. This makes it easy to devise an explanation facility, so that the actual
obtained ranking can be immediately enriched with its logical explanation; thus improving
users’ trust and interaction with the matchmaking system.
We now prove that p is in accordance with properties higlighted in the previous Section.
Since the computation of Formula (1) starts by putting concepts C,D in normal form, we
recall that the normal form of C can be summarized as Cnames CCall, and similarly for
D. Without ambiguity, we use the three components also as sets of the conjoined concepts.
Theorem 3 The penalty function p is (i) non-symmetric, (ii) syntax independent, and
(iii) monotonic over subsumption.
Proof. (i) Non-symmetricity is easily proved by providing an example: p(A,	, ∅) =
p(	, A, ∅). In fact, ﬁndIrred (〈ALN , A,	, ∅〉) ﬁnds H1 = 	 as a solution (A  	 without
further hypothesis) while ﬁndIrred (〈ALN ,	, A, ∅〉) ﬁnds H2 = A. Recalling that |	| = 0,
while |A| = 1, we get the ﬁrst claim.
(ii) Syntax independence follows from the fact that normal forms are used in Formula (1),
and as already said normal forms are unique up to commutativity of conjunction.
286
Semantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach
(iii) Monotonicity over subsumption is proved by analyzing the conditions for subsump-
tion in ALN . A concept C ′ is subsumed by a concept C whenever all conditions below
hold. For each condition, we analyze the changes in the behavior of ﬁndIrred , proving that
the provided solution H just adds other conjuncts. Recall that monotonicity over sub-
sumption is applied only to potential matches, hence we assume that both C and C ′ are
consistent with D. Since ﬁndIrred is recursive, the proof is also by induction on the quan-
tiﬁcation nesting (QN) of C ′. For C ′ having QN equal to 0, C ′ can only be a conjunction
of atomic concepts—names, negated names, number restrictions. Then the conditions for
subsumption are the following:
• The ﬁrst condition is that Cnames+ ⊆ C ′names+. Hence, in Step 1.1 of ﬁndIrred , the
number of concept names that are added to H ′—with respect to names added to H—
can only decrease, and so |H ′| ≤ |H| considering names. Regarding negated names,
observe that they do not contribute to the solution of ﬁndIrred , since they come from
a disjointness axiom and a positive name (that contributes).
• The second condition is that for every number restriction in C, either the same
number restriction appears in C ′, or it is strengthened (an at-least increases, an at-
most decreases) in C ′. Hence, number restrictions added by Steps 2.1 and 3.1 to H ′
can be either as many as those added to H, or less. Again, also considering number
restrictions |H ′| ≤ |H|.
The above two cases prove the basis of the induction (C ′ with QN equal to 0). Suppose now
the claim holds for concepts C ′ with QN n or less, and let C ′ have a QN of n + 1. Clearly,
in this case C ′ has at least one universal role quantiﬁcation—call it ∀R.F ′. The condition
for subsumption between C ′ and C is the following:
• Either for every universal role quantiﬁcation ∀R.F in C over the same role R, it must
hold F ′ T F , or there is no universal role quantiﬁcation on R in C. In the former
case, observe that ﬁndIrred is recursively called6 in Step 4.1.1 with arguments F , E,
and F ′, E; we call I and I ′, respectively, the solutions returned by ﬁndIrred . Observe
that the QN of F ′ is n or less, hence by inductive hypothesis |I ′| ≤ |I|. Since Step 4.1.1
adds ∀R.I ′ and ∀R.I to H ′ and H, again |H ′| ≤ |H|. If instead there is no universal
role quantiﬁcation on R in C, Step 4.1.2 adds ∀R.E to H. If also C ′ does not contain
any role quantiﬁcation on R, then Step 4.1.2 adds ∀R.E also to H ′, then H ′ cannot
be longer than H in this case. If a role quantiﬁcation ∀R.F ′ is in C ′, then Step 4.1.1
makes a recursive call with arguments F ′, E. In this case, the solution returned I ′
has length less than or equal to |E|, hence the length of H ′ cannot be longer than the
length of H also in this case.
In summary, if C ′ T C then in no case the length of H ′ increases with respect to the
length of H. This proves the monotonicity over subsumption of p.
Intuitively, we could say that monotonicity over subsumption for potential matches means
“the more speciﬁc C is, the lower its penalty, the better its ranking w.r.t. D”. More
6. ﬁndIrred is called only once, because concepts in CNF have at most one universal role quantiﬁcation
over any role R.
287
Di Noia, Di Sciascio & Donini
precisely—but less intuitively—we should say that “the rank of C w.r.t. D cannot worsen
when C is made more speciﬁc”. Hence, given an oﬀer D, a TBox T , a sequence of in-
creasingly speciﬁc counteroﬀers C1 T C2 T C3 T · · · are assigned to a sequence of
non-increasing penalties p(C1,D,T ) ≥ p(C2,D,T ) ≥ p(C3,D,T ) ≥ . . . We now prove
that such sequences are well-founded, with bottom element zero, reached in case of sub-
sumption.
Proposition 4 p(C,D,T ) = 0 if and only if C T D.
Proof. Recall from Section 3.1 that 	 and ⊥ are the only concepts of length zero, and
ﬁndIrred returns ⊥ if and only if C and D are not in a potential match (Step 0 in ﬁndIrred).
Hence, p(C,D,T ) = 0 if and only if the concept whose length is computed in Formula (1)
is 	. By construction of ﬁndIrred , 	 is returned by the call
ﬁndIrred (〈ALN ,CNF (C,T ),CNF (D,T ), ∅〉) if and only if CNF (C,T )  CNF (D,T ), which
holds (see Borgida & Patel-Schneider, 1994) if and only if C T D.
Moreover, we could also prove that adding to C details that are irrelevant for D leaves the
penalty unaﬀected, while adding to C details that are relevant for D lowers C’s penalty.
Note also that in Formula (1) we take T into account in the normal form of C,D, but
then we forget it—we use an empty TBox—when calling ﬁndIrred . We explain such a choice
with the aid of an example.
Example 2 Given T = {A  A1  A2}, let D = A be a Demand with the two following
supplies: C1 = A2, C2 = 	. Observe that CNF (D,T ) = A  A1  A2,CNF (C1,T ) =
A2,CNF (C2,T ) = 	. If we used the following formula to compute the penalty
p′(C,D,T ) .= |ﬁndIrred (〈ALN , C,D, ∅〉)| (2)
and ran the algorithm ﬁndIrred (〈ALN , C1,D,T 〉) and ﬁndIrred (〈ALN , C2,D,T 〉), before
Step 5 we would get, respectively,
H1 = A1 A
H2 = A1 A2 A
and after Step 5 ﬁndIrred would return H ′1 = H ′2 = A, hence C1 and C2 would receive
the same penalty. However, we argue that C1 is closer to D than C2 is, because it con-
tains a characteristic (A2) implicitly required by D, while C2 does not. If instead we call
ﬁndIrred (〈ALN ,CNF (C1,T ),CNF (D,T ), ∅〉) and
ﬁndIrred (〈ALN ,CNF (C2,T ),CNF (D,T ), ∅〉), we get the solutions H1 and H2 above—and
Step 5 does not delete any conjunct, since T = ∅. Therefore, C1 gets penalty 2, while C2
gets penalty 3, highlighting what is more speciﬁed in C1 w.r.t. C2.
More generally, we can say that the reducibility step (Step 5 in ﬁndIrred) ﬂattens a solution
to its most speciﬁc conjuncts, leaving to the TBox the implicit representation of other
characteristics, both the ones already present in the supply and those not present. Therefore,
making an empirical decision, we consider the TBox in the normal form of C and D, but
we exclude it from further reductions in Step 5 of ﬁndIrred .
288
Semantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach
Remark 2 Although the deﬁnition of Concept Abduction could appear similar to Concept
Diﬀerence, it is not so. We note that generically speaking, the name “Concept Abduction”
appeals to logic, while “Concept Diﬀerence” appeals to algebra (although Diﬀerence has
multiple solutions when L includes universal role quantiﬁcation). More precisely, we recall
(Teege, 1994) that diﬀerence is deﬁned as: C−D = max {E ∈ L : (E D) ≡ C} provided
that C  D. A more specialized deﬁnition of diﬀerence (Brandt, Ku¨sters, & Turhan, 2002)
refers only to DLs ALC and ALE. It is deﬁned as: C − D = min{E ∈ L : (E  D) ≡
(CD)}—where C,E ∈ ALC, D ∈ ALE, and minimality is w.r.t. a preorder  on a speciﬁc
normal form which extends CNF to ALC. No TBox is taken into account.
Instead, the solution of a CAP 〈L, C,D,T 〉 does not require that C T D, but only that
C D T ⊥. In general, when D T C if we let H = D − C in a CAP P = 〈L, C,D,T 〉
we get those solutions for which C H ≡ D—which obviously are not all solutions to P.
Hence D−C ⊆ SOL(P), but not vice versa (see the proof of Proposition 2 for an example).
When C T D this comparison is not even possible, since D−C is undeﬁned. However, in
a generic setting, e.g., in an e-commerce scenario, subsumption between demand and supply
is quite uncommon; most of oﬀers are such that neither subsumes the other. Because of this
greater generality, for our speciﬁc application to matchmaking, Concept Abduction seems
more suited than Concept Diﬀerence to make a basis for a penalty function.
6. Concept Contraction
If DC is unsatisﬁable in T , but the demander accepts to retract some of D’s constraints,
partially matching supplies may be reconsidered. However, other logic-based approaches
to matchmaking by Trastour et al. (2002), Sycara et al. (2002), Li and Horrocks (2003)
usually exclude the case in which the concept expressing a demand is inconsistent with the
concept expressing a supply, assuming that all requirements are strict ones. In contrast,
we believe that inconsistent matches can still be useful, especially in e-marketplaces. In
fact, partial (a.k.a. disjoint) matches can be the basis for a negotiation process, allowing
a user to specify negotiable requirements—some of which could be bargained in favor of
other. Such a negotiation process can be carried out in various ways adopting approaches
to matchmaking not based on logic (e.g., Stro¨bel & Stolze, 2002), but also, as shown in
practice by Colucci et al. (2005), using Belief Revision. In fact, the logical formalization
of conﬂicting matches, aimed at ﬁnding still “interesting” inconsistent matches without
having to revert to text-based or hybrid approaches, can be obtained exploiting deﬁnitions
typical of Belief Revision. In accordance with Ga¨rdenfors (1988) formalization, revision of
a knowledge base K with a new piece of knowledge A is a contraction operation, which
results in a new knowledge base K−A such that K−A |= ¬A, followed by the addition of A
to K−A—usually modeled by conjunction. We call Concept Contraction our adaptation of
Belief Revision to DLs.
Starting with C  D unsatisﬁable in a TBox T , we model with Concept Contraction
how, retracting requirements in C, we may still obtain a concept K (for Keep) such that
K D is satisﬁable in T . Clearly, a user is interested in what he/she must negotiate on to
start the transaction—a concept G (for Give up) such that C ≡ G K.
289
Di Noia, Di Sciascio & Donini
For instance, with reference to the ontology in Figure 1, if a user demands Dem and a
supplier oﬀers Sup, where Dem and Sup are described as follows:
Dem = HomePC  ∀hasMonitor.LCDmonitor
Sup = HomePC  ∀hasMonitor.CRTmonitor
it is possible to check that Sup Dem is unsatisﬁable. This is a partial match. Yet, in this
case, if the demander gives up the concept G = ∀hasMonitor.LCDmonitor and keeps the
concept K = HomePC, K  Sup is satisﬁable, hence K now potentially matches Sup.
More formally we model a Concept Contraction problem as follows.
Deﬁnition 10 (Concept Contraction) Let L be a DL, C, D, be two concepts in L, and
T be a set of axioms in L, where both C and D are satisﬁable in T . A Concept Contraction
Problem (CCP), denoted as 〈L, C,D,T 〉, is ﬁnding a pair of concepts 〈G,K〉 ∈ L×L such
that T |= C ≡ GK, and KD is satisﬁable in T . We call K a contraction of C according
to D and T .
We use Q as a symbol for a CCP, and we denote with SOLCCP (Q) the set of all
solutions to a CCP Q. Observe that as for concept abduction, we rule out cases where
either C or D are unsatisﬁable, as they correspond to counterintuitive situations. We note
that there is always the trivial solution 〈G,K〉 = 〈C,	〉 to a CCP. This solution corresponds
to the most drastic contraction, that gives up everything of C. On the other hand, when
C D is satisﬁable in T , the “best” possible solution is 〈	, C〉, that is, give up nothing.
As Concept Abduction extends Subsumption, Concept Contraction extends satisﬁability—
in particular, satisﬁability of a conjunction C D. Hence, results about the complexity of
deciding Satisﬁability of a given concept carry over to Contraction.
Proposition 5 Let L be a DL containing AL, and let Concept Satisﬁability w.r.t. a TBox
in L be a problem C-hard for a complexity class C. Then deciding whether a given pair of
concepts 〈G,K〉 is a solution of a CCP Q =〈L, C,D,T 〉 is C-hard.
Proof. A concept E ∈ L is satisﬁable w.r.t. a TBox T if and only if the CCP 〈L, C,D,T 〉
has the solution 〈	, C〉, where C = ∀R.E and D = ∃R.	. Then, L should contain at least
universal role quantiﬁcation (to express ∀R.E), unqualiﬁed existential role quantiﬁcation
(to express ∃R.	), conjunction (to express that C ≡ G K) and at least the unsatisﬁable
concept ⊥ (otherwise every concept is satisﬁable, and the problem trivializes). The mini-
mal, known DL containing all such constructs is the DL AL.
This gives a lower bound on the complexity of Concept Contraction, for all DLs that
include AL. For DLs not including AL, note that if the proof showing C-hardness of
satisﬁability involves a concept with a topmost  symbol, the same proof could be adapted
for Concept Contraction.
Obviously, a user in a marketplace is likely to be willing to give up as few things as
possible, so some minimality in the contraction G must be deﬁned. We skip for conciseness
the deﬁnitions of a minimal-length contraction and subsumption-maximal contraction, and
deﬁne straightforwardly conjunction-minimal contraction for DLs that admit a normal form
made up of conjunctions.
290
Semantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach
Deﬁnition 11 Let Q =〈L, C,D,T 〉 be a CCP in which L admits a CNF. The set SOLCCP(Q)
is the subset of SOLCCP (Q) with the following property: if 〈G,K〉 ∈ SOLCCP(Q) then
for no sub-conjunction G′ of G it holds 〈G′,K〉 ∈ SOLCCP (Q). We call such solutions
irreducible.
6.1 Number-Restriction Minimal Contractions
In what follows we focus on a speciﬁc class of irreducible solutions for a CCP 〈ALN , C,D,T 〉
exposing interesting characteristics from a user-oriented point of view in a matchmaking
scenario. Before deﬁning such a class we explain the rationale behind its investigation using
the following example.
Example 3 Suppose we have the following situation:
demand Dem = HomePC  ∀hasMonitor.LCDmonitor
supply Sup = Server  ∀hasMonitor.CRTmonitor
As T |= DemSup ≡ ⊥ the demander can contract Dem in order to regain the satisﬁability
with Sup. Two solutions for the CCP Q = 〈ALN ,Dem ,Sup,T 〉 are:⎧⎪⎨
⎪⎩
G≥ = HomePC
K≥ = PC  (≥ 1 hasSoftware)  (= 1 hasOS)
 ∀hasMonitor.LCDmonitor
{
G∀ = ∀hasMonitor.LCDmonitor
K∀ = HomePC
In 〈G≥,K≥〉 the demander should give up the speciﬁcation on HomePC; in 〈G∀,K∀〉 the
demander should give up only some speciﬁcations on the monitor type while keeping the
rest.
Observe that both solutions are in the previously deﬁned class SOLCCP(Q), but from
a user-oriented point of view, 〈G∀,K∀〉 seems the most reasonable solution to Q. Giving
up the HomePC concept in Dem—and then (≥ 1 hasMonitor) because of the axiom on
HomePC—the demander keeps all the speciﬁcations on requested components, but they are
vacuously true, since K≥  Sup implies ∀hasMonitor.⊥ i.e., no component is admitted.
In order to make our intuition more precise, we introduce the number-restriction-minimal
solutions for Q, whose set we denote SOLCCPN (Q). Intuitively, a solution 〈G,K〉 for Q is
in SOLCCPN (Q) when an at-least restriction (≥ n R) is in G only if it directly conﬂicts
with an at-most restriction (≤ m R) (with m < n) in D. Solutions in which the at-
least restriction is given up because of conﬂicting universal role quantiﬁcations—e.g., ∀R.A
and ∀R.¬A—are not in SOLCCPN (Q). Since this characteristic of number-restriction-
minimal solutions should be enforced at any level of nesting, we ﬁrst introduce the role
path of a concept in ALN . Here we need to distinguish between a concept A and its
(diﬀerent) occurrences in another concept, e.g., B = A  ∀R.A. In theory, we should mark
each occurrence with a number, e.g., A1  ∀R.A2; however, since we need to focus on one
occurrence at a time, we just mark it as A.
291
Di Noia, Di Sciascio & Donini
Deﬁnition 12 Given a concept B in ALN , and an occurrence A of an atomic (sub)concept
A in B, a role path for A in B, ΠA(B) is a string such that:
– ΠA(A) = , where  denotes the empty string
– ΠA(B1  B2) = ΠA(Bi), where Bi, i ∈ {1, 2}, is the concept in which the occurrence
of A appears
– ΠA(∀R.B) = R ◦ ΠA(B), where ◦ denotes string concatenation
The role path ΠA(B) represents the role nesting of a concept A occurrence into a concept
B. Note that ΠA(B) is the same for any commutation of conjunctions in B, and for any
rearrangement of universal role quantiﬁcations—if A was not atomic, this would not be
true7. Using the previous deﬁnition we can now deﬁne SOLCCPN (Q).
Deﬁnition 13 Let Q = 〈ALN , C,D,T 〉 be a CCP. The set SOLCCPN (Q) is the subset
of solutions 〈G,K〉 in SOLCCP(Q) such that if (≥ n R) occurs in G then there exists
(≤ m R), with m < n, occurring in CNF (D,T ) and Π(≥ n R)(G) = Π(≤ m R)(CNF (D,T )).
We now illustrate an algorithm ﬁndContract that returns a solution 〈G,K〉 ∈ SOLCCPN (Q)
for Q = 〈ALN ,CNF (C,T ),CNF (D,T ), ∅〉, that is, it compares two ALN -concepts C, and
D, both already in CNF w.r.t. a TBox T , and computes a number-restriction minimal con-
traction 〈G,K〉 of C w.r.t. D without considering the TBox.
Algorithm ﬁndContract(C,D);
input ALN concepts C, D, both already in CNF
output number-restriction minimal contraction 〈G,K〉,
where 〈G,K〉 = 〈	, C〉 means that C D is satisﬁable
variables concepts G,K,G′,K ′
begin
1. if C = ⊥
then return 〈⊥,	〉; /* see comment 1 */
2. G := 	;K := 	 C; /* see comment 2 */
3. for each concept name A ∈ Knames+
if there exists a concept ¬A ∈ Dnames¬
then G := G A; delete A from K;
4. for each concept (≥ x R) ∈ K
such that there is a concept (≤ y R) ∈ D with y < x
G := G  (≥ x R); delete (≥ x R) from K;
5. for each concept (≤ x R) ∈ K
such that there is a concept (≥ y R) ∈ D with y > x
G := G  (≤ x R); delete (≤ x R) from K;
6. for each concept ∀R.F ∈ Kall
if there exist ∀R.E ∈ Dall and (
either (≥ x R) ∈ K with x ≥ 1
7. For readers that are familiar with the concept-centered normal form of concepts (Baader et al., 2003),
we note that Π
A
(B) is a word for UA in the concept-centered normal form of B.
292
Semantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach
or (≥ x R) ∈ D with x ≥ 1 )
then let 〈G′,K ′〉 be the result of ﬁndContract(F,E) in
G := G  ∀R.G′;
replace ∀R.F in K with ∀R.K ′;
7. return 〈G,K〉;
end.
Let us comment on the algorithm:
1. the case in Step 1 cannot occur at the top level, since we assumed C and D be satisﬁ-
able in the deﬁnition of CCP. However, ⊥may occur inside a universal quantiﬁcation—
e.g., C = ∀R.⊥—hence, the case of Step 1 may apply in a recursive call of ﬁndContract ,
issued from Step 6 of an outer call.
2. in Step 2, the conjunction 	  C is assigned to K in order to leave 	 in K if every
other concept is removed by the subsequent steps.
We denote by 〈G∅,K∅〉 solutions for the CCP Q∅ = 〈ALN ,CNF (C,T ),CNF (D,T ), ∅〉. In
this simpliﬁed CCP Q∅, we completely unfold T in both C and D and then forget it.
Theorem 4 The pair 〈G,K〉 computed by ﬁndContract(C,D) is a number-restriction-
minimal contraction for Q∅ = 〈ALN ,CNF (C,T ),CNF (D,T ), ∅〉.
Proof. We ﬁrst prove that 〈G,K〉 is a solution for Q∅, namely, that (i) G  K ≡ C,
and that (ii) K D is satisﬁable. We prove (i) by induction. For the base cases, observe
that the claim is true in Step 2 by construction, and that in Steps 3–5 when a conjunct
is deleted from K, it is also added to G. Hence the claim holds when no recursive call is
made. For the inductive case, assume the claim holds for each recursive call in Step 6, that
is, G′ K ′ ≡ F for every concept ∀R.F ∈ Kall. Let Gn, Kn be the values of variables G,K
before the execution of Step 6, and let K−n be the concept Kn without ∀R.F . Then, after
Step 6 it is:
G K = (by assigment)
Gn  ∀R.G′ K−n  ∀R.K ′ ≡ (by deﬁnition of ∀)
Gn K−n  ∀R.(G′ K ′) ≡ (by inductive hypothesis)
Gn K−n  ∀R.F ≡ (by deﬁnition of K−n )
Gn Kn ≡ (since the base case holds before Step 6)
C
Regarding (ii), the proof is again by induction, where the inductive hypothesis is that
K ′  E is satisﬁable. Basically, we construct an interpretation (Δ, ·I) with an element x
such that x ∈ (K D)I , and show that we can keep constructing I without contradictions,
since contradicting concepts have been deleted from K. In the inductive case, we assume
the existence of an interpretation (Δ′, ·J ) for K ′E such that y ∈ Δ′∩(K ′E)J , and then
build a joint interpretation (Δ′′, ·I′′) by letting Δ′′ = Δ⊎Δ′,I ′′ = I ∪ J ∪ {〈x, y〉 ∈ RI′′}.
We now prove that 〈G,K〉 is a number-restriction-minimal solution for Q∅. The proof
is by induction on the Quantiﬁcation Nesting (QN) of C, deﬁned in Section 3.1. Observe
that an at-least restriction is deleted from K only in Step 4 of ﬁndContract . For the base
case—QN(C) = 0, no recursive call—observe that the role path of a retracted concept
293
Di Noia, Di Sciascio & Donini
(≥ n R) in G is , same as the role path of the concept (≤ m R) in D causing Step 4 to
be executed. Hence, the claim holds in the base case. For the inductive case, assume that
the claim holds for all concepts with QNs smaller than QN(C). Observe that the concept
F in Step 6 is such a concept, since its QN is smaller by at least 1. Hence, if an (occurrence
of an) at-least restriction (≥ x R), with role path Π
(≥ x R)(F ) is deleted in F , there exists
a conﬂicting at-most restriction in E with the same role path. Since both F and E occur
inside the scope of a concept ∀R.F , ∀R.E respectively, the claim still holds with role path
Π
(≥ x R)(C) = R ◦ Π(≥ x R)(F ).
6.2 Contraction-Based Ranking of Partial Matches
We now deﬁne a penalty function p⊥ for partial matches based on the following intuition:
the partial matches should be ranked based on how many characteristics should be retracted
from each C to make them potential matches.
Algorithm penaltyPartial (C,D);
input ALN concepts C, D, both already in CNF
output a penalty for the partial match between C and D
where zero means that C D is satisﬁable
variables integer n
begin
1. if C = ⊥
then return |D|; /* see Comment 1 */
2. n = 0;
3. for each concept name A ∈ Cnames+
if there exists a concept ¬A ∈ Dnames¬
then n := n + 1;
4. for each concept (≥ x R) ∈ C
such that there is a concept (≤ y R) ∈ D with y < x
n := n + 1;
5. for each concept (≤ x R) ∈ C
such that there is a concept (≥ y R) ∈ D with y > x
n := n + 1;
6. for each concept ∀R.F ∈ Call
if there exist ∀R.E ∈ Dall and (
either ((≥ x R) ∈ C and (≤ y R) ∈ D with x ≥ y) /* see Comment 2 */
or (≥ x R) ∈ D with x ≥ 1 )
then n := n + penaltyPartial (F,E);
7. return n;
end.
The above algorithm has a structure very similar to ﬁndContract : whenever ﬁndContract
removes concepts from K, penaltyPartial adds penalties to n. The two diﬀerences are
explained in the following comments:
294
Semantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach
1. Step 1 adds the whole length of D when C = ⊥. This addition ensures antimonotonic-
ity in the presence of ⊥, as explained in Example 4 below.
2. Step 6 has in penaltyPartial the additional condition “and (≤ y R) ∈ D with x ≥ y”.
This condition is necessary because penaltyPartial does not actually remove concepts,
but just counts them. If an at-least restriction in C is in contrast with an at-most
restriction in D, then ﬁndContract removes it from K, while penaltyPartial just adds
1 to n. Yet, when the condition in Step 6 is evaluated, ﬁndContract ﬁnds it false just
because the at-least restriction has been removed, while penaltyPartial would ﬁnd it
true, were it not for the additional condition.
We now use the outcome of penaltyPartial to deﬁne a penalty function for partial matches.
Deﬁnition 14 Given a simple TBox T in ALN , let the penalty function p⊥ for the partial
match of a counteroﬀer C given an oﬀer D, where both C and D are concepts in ALN , be
as follows.
p⊥(C,D,T ) .= penaltyPartial (CNF (C,T ),CNF (D,T )) (3)
Note that since penaltyPartial closely follows ﬁndContract and ﬁndIrred , in fact Formula (3)
is more similar to Formula (1) in Deﬁnition 9 than it might appear. Implicitly, we solve
Q∅ = 〈ALN ,CNF (C,T ),CNF (D,T ), ∅〉, and then use the result in the computation of the
penalty function, with a main diﬀerence in Step 1, though. We explain such a diﬀerence
with the help of an example.
Example 4 Let Dem1 and Dem2 be two demands, where Dem2 T Dem1, and let Sup be
a supply, all modeled using the ontology T in Figure 1 as in the following:
Dem1 = PC  ∀hasMonitor.CRTmonitor
Dem2 = PC  ∀hasMonitor.⊥
Sup = HomePC  ∀hasMonitor.LCDmonitor
Computing ﬁndContract and penaltyPartial for both CNF (Dem1,T ) and CNF (Dem2,T )
w.r.t. CNF (Sup,T ) we obtain:
ﬁndContract(CNF (Dem1,T ),CNF (Sup,T )) = 〈∀hasMonitor.CRTmonitor,
PC  ∀hasMonitor.Monitor〉
penaltyPartial (CNF (Dem1,T ),CNF (Sup,T )) = 1
ﬁndContract(CNF (Dem2,T ),CNF (Sup,T )) = 〈∀hasMonitor.⊥, PC〉
penaltyPartial (CNF (Dem2,T ),CNF (Sup,T )) = 3
In summary, the concept ⊥ conﬂicts with every other concept, yet when a concept
∀R.⊥ is given up, its length is zero (or any other constant), hence the length of G cannot
be directly used as an antimonotonic penalty function. This explains the importance of
Step 1 in the above algorithm.
We can show the following formal correspondence between p⊥ and the Concept Contraction
deﬁned in the previous Section.
295
Di Noia, Di Sciascio & Donini
Theorem 5 Let Q = 〈ALN , C,D,T 〉 be a CCP, and let 〈G∅,K∅〉 the solution to Q∅ re-
turned by ﬁndContract (CNF (C,T ),CNF (D,T )). If G∅ does not contain any occurrence of
the concept ⊥, then
p⊥(C,D,T ) = |G∅|
Proof. The function p⊥ is based on penaltyPartial , and by inspection, whenever penaltyPartial
increments n, ﬁndContract adds an atomic concept to G∅. The only exception is in Step 1
of penaltyPartial , which adds |D| while ﬁndContract adds ⊥ to G∅. However, this case is
explicitly outside the claim.
We now prove that p⊥ is in accordance with properties highlighted in the previous Section.
Theorem 6 The penalty function p⊥ is (i) non-symmetric, (ii) syntax independent, and
(iii) antimonotonic over subsumption.
Proof. (i) Non-symmetry is proven by example: let C = (≤ 1 R)  ∀R.¬A, D =
(≥ 2 R)  ∀R.A. For simplicity, T = ∅, and observe that both C and D are already in
CNF. We now show that p⊥(C,D, ∅) = p⊥(D,C, ∅). In fact, in the former case, observe that
C must give up everything: the at-most restriction because it is in contrast with the at-least
restriction, and ¬A inside universal quantiﬁcation because it is in contrast with ∀R.A in
D. Hence, penaltyPartial returns 2 = (1 from Step 5) + (1 from Step 1 of the recursive
call). Hence, p⊥(C,D, ∅) = 2. In the latter case, instead, once the at-least restriction is
given up (and penaltyPartial adds 1 to n in Step 4), since role ﬁllers are no more imposed,
the universal quantiﬁcation is now compatible (the condition of the if in Step 6 is false).
Hence p⊥(D,C, ∅) = 1.
(ii) syntax independency is an immediate consequence of the fact that Formula (3)
uses normal forms for concepts. Since normal forms are unique up to commutativity of
conjunction—that can be ﬁxed by imposing some order to conjunctions, e.g., lexicographic—
the claim holds.
(iii) antimonotonicity can be proved by induction on the QN of a generic concept C ′
subsumed by C; we go through all conditions for subsumption, analyzing the changes in
the behavior of the algorithm from C to C ′. Recall that our goal is now to prove that
p⊥(C ′,D,T ) ≥ p⊥(C,D,T ). In order to make a clear distinction between the two compu-
tations, we let n′ be the (instance of the) variable used in the call to penaltyPartial (C ′,D),
while n is used in the call to penaltyPartial (C,D). To ease notation, we assume that C,C ′
are already in CNF.
• First of all, it could be the case that C ′ = ⊥. In this case, n′ = |D| from Step 1 of
penaltyPartial . On the other hand, observe that penaltyPartial (C,D) ≤ |D| because
either C = ⊥ too, or every increase in n corresponds to an atomic concept in D—by
inspection of Steps 3–5, and this recursively in Step 6. Therefore, the claim holds for
this base case.
• Cnames ⊆ C ′names. For this case, it is obvious that Step 3 in penaltyPartial can only
make more increments to n′ w.r.t. n, since for C ′ the number of iterations of the for
each increases.
296
Semantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach
• for every number restriction in C, either the same number restriction appears in C ′,
or it is strengthened (an at-least increases, an at-most decreases) in C ′. Note that
strengthening a number restriction in C ′ can only turn from false to true the condition
for the increment of n in Steps 4–5. For instance, passing from (≥ x R) ∈ C to
(≥ x′ R) ∈ C ′ with x′ ≥ x, if there is (≤ y R) ∈ D then y < x implies y < x′. A
similar argument holds for the at-most. Moreover, number restrictions that appear
only in C ′ can only increase the number of iterations of Steps 4–5, hence n′ can only
increase w.r.t. n and the claim holds.
The above three cases prove the basis of the induction (C ′ with QN equal to 0). We now
prove the case for universal role quantiﬁcation, assuming that the claim holds for QNs less
than QN(C ′).
• for every ∀R.F ′ ∈ C ′all, either R is not universally quantiﬁed in Call, or there is
∀R.F ∈ Call such that F ′ is subsumed by F (with F ′ = F as a special case of subsump-
tion). Roles which are not universally quantiﬁed in Call but are quantiﬁed in C ′all,
can only increase the number of iterations of Step 6, hence n′ can only increase due to
their presence. For roles that have a more speciﬁc restriction F ′, the inductive hypoth-
esis is assumed to hold, since QN(F ′) < QN(C ′). Hence p⊥(F ′, E,T ) ≥ p⊥(F,E,T ).
This is equivalent to penaltyPartial (F ′, E) ≥ penaltyPartial (F,E). Moreover, if the
condition in Step 6 is true in the call penaltyPartial (C,D), then it is also true in
penaltyPartial (C ′,D), since ∀R.F ′ ∈ C ′all, and (≥ x′ R) ∈ C ′, hence if the recursive
call penaltyPartial (F,E) is issued, then also penaltyPartial (F ′, E) is issued, increasing
n′ at least as much as n is increased, by inductive hypothesis. Hence the claim holds
also in the inductive case.
7. The Matchmaking System
The DLs-based approach to semantic matchmaking illustrated in previous Sections has been
implemented in the ALN reasoning engine MaMaS (MatchMaking Service). It features all
classical inference services of a DL reasoner, but also implements algorithms for the non-
standard services for matchmaking presented in previous Sections.
MaMaS is a multi-user, multi-ontology Java servlet based system; it is available as an
HTTP service at: http://dee227.poliba.it:8080/MAMAS-tng/DIG, and exposes a DIG
1.18 compliant interface. The basic DIG 1.1 has been extended to cope with non standard
services, and we brieﬂy describe here such additions.
New elements:
• Match type detection: <matchType>E1 E2</matchType>- computes the match type
according to the following classiﬁcation: Exact (equivalence), Full, Plug-in, Potential,
Partial.
8. DIG 1.1 is the new standardized DL systems interface developed by the Description Logic Implementation
Group (DIG) (Haarslev & Mo¨ller, 2003).
297
Di Noia, Di Sciascio & Donini
• Concept Abduction: <abduce>E1 E2</abduce> - implements ﬁndIrred .
• Concept Contraction: <contract>E1 E2</contract>- implements ﬁndContract .
• Ranking Score: <rank type="potential">E1 E2</rank>
<rank type="partial">E1 E2</rank>- computes p(C,D,T ) and p⊥(C,D,T ) as
presented in previous Sections.
New attributes for <newKB/>
• shared: the only values to be used are true and false. In MaMaS, when a new
knowledge base is created, each KB uri is associated with the IP address of the client
host (owner) instantiating the KB. If the shared attribute is set to false, only the
owner is authorized to submit tells statements and change the KB as well as to submit
asks. In this case, requests from IP addresses diﬀerent from the owner’s one can be
only asks. If the shared attribute is set to true, then no restriction is set on both
tells and asks statements. True is the default value.
• permanent: the only values to be used are true and false. In MaMaS, if a KB is
not used for more than 300 seconds, the KB is automatically released. If a user wants
to maintain the KB indeﬁnitely, the permanent attribute must be set to true; false
is the default value.
It should also be pointed out that MaMaS only supports simple-TBox, that is, concept
axioms have a concept name on the left side9.
We have been using MaMaS as matching engine in various applications, including e-
marketplaces, (see e.g., Colucci, Di Noia, Di Sciascio, Donini, Ragone, & Rizzi, 2006;
Colucci et al., 2005) and semantic web services discovery (Ragone, Di Noia, Di Sciascio,
Donini, Colucci, & Colasuonno, 2007). We do not delve in details of such applications here,
and refer the interested reader to the cited references.
7.1 Experimental Evaluation
The hypothesis we seek to conﬁrm in this Section is that our approach performs eﬀectively
in a wide range of matchmaking scenarios, i.e., it is able to model commonsense human
behavior in analyzing and ranking, given a request, available oﬀers. Hence the experimental
framework relies on comparison of system behavior versus the judgement of human users.
Furthermore, although our system may allow the use of weights to increase the relevance of
concepts, in the following results refer to the basic “unweighted” version of the system, to
avoid biasing of results due to weights introduction.
The scenarios we tested our approach on were three: apartments rental, date/partner
ﬁnding, skill management for recruiting agencies. Several ontology design methodologies
have been proposed (Jones, Bench-Capon, & Visser, 1998); we adopted the one proposed
by N.F. Noy and D.L. McGuinness (2001).
9. Notice that since MaMaS supports ALN , only atomic negation can be expressed and then <disjoint/>
groups must contain only concepts specialized by an <impliesc> axiom (sub-concept axiom). Deﬁned
concepts <equalc/> (same-class) are not admitted in a disjoint group.
298
Semantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach
For all three scenarios we carried out a thorough domain analysis, starting with a large
set of advertisements taken from newspapers or from descriptions of on-line agencies, and
designed ontologies describing the domain. In particular:
• Apartments rental ontology is made up of 146 concepts (primitive + deﬁned) and 33
roles.
• Date/partner matching ontology is made up of 131 concepts (primitive + deﬁned)
and 29 roles.
• Skill matching ontology is made up of 308 concepts (primitive + deﬁned) and 38 roles.
For each scenario we selected several announcements. The total number used in the ex-
periments with human users is 180 (120 oﬀers, 60 requests) for the apartments rental, 215
(140 oﬀers, 75 requests) for the skill matching. 100 advertisements for the Date matching
scenario were also selected, yet for these we did not actually distinguish among requests
and oﬀers as announcements were in the form of proﬁles, although they included preferences
for dating partner. All announcements were in natural language and they were manually
translated in DL syntax. We then created, for each domain, 50 sets of questionnaires.
Questionnaires were in the form of one request (a demand or a supply) and 10 oﬀering ad-
vertisements. Three groups of ten randomly selected volunteers, were then asked to order,
according to their judgement advertisements, with respect to the given requests. Having
obtained average users rankings, we run the same sets of advertisements with our system,
which gave us a set of system provided rankings. System rankings that included partial
matching advertisements were simply ordered below worst potential matching advertise-
ment. We adopted, as reference, a standard Vector Space Model (VSM) (Salton & Gill,
1983) system. We used terms in our ontologies “ﬂattening” the ontology descriptions, as di-
mensions of three separate vector spaces, and determined weights using classical TF ∗ IDF
measure. Similarity results were computed using the well-known Cosine similarity measure
(Salton & Gill, 1983).
To summarize results we adopted the Rnorm (Bollmann, Jochum, Reiner, Weissmann,
& Zuse, 1985) as quality measure of our system eﬀectiveness. Rnorm is deﬁned as follows.
Given Sup, a ﬁnite set of descriptions with a user-deﬁned preference relation ≥ that is
complete and transitive, let Δusr be the rank ordering of Sup induced by users preference
relation, and let Δsys be the system-provided ranking. Rnorm is then deﬁned as:
Rnorm(Δsys) =
1
2
· (1 + S
+ − S−
S+max
)
where S+ is the number of descriptions pairs where a better description is ranked by the
system ahead of a worse one; S− is the number of pairs where a worse description is ranked
ahead of a better one and S+max is the maximum possible number of S+. It should be noticed
that the calculation of S+, S−, and Smax is based on the ranking of descriptions pairs in
Δsys relative to the ranking of corresponding descriptions pairs in Δusr. Rnorm values are
in the range [0,1]; a value of 1 corresponds to a system-provided ordering of the available
descriptions that is either identical to the one provided by the human users or has a higher
degree of resolution, lower values correspond to a proportional disagreement between the
two. For the three scenarios considered, results are presented in table 3.
299
Di Noia, Di Sciascio & Donini
Domain MaMaS VSM
Apartments rental 0.87 0.48
Date/partner matching 0.79 0.41
Skill matching 0.91 0.46
Table 3: Rnorm values: MaMaS: Semantic matchmaking results, VSM: Vector Space Model
results
Although they present a variability, which we believe is partly due to the ability to
capture the domain in the ontologies design, they show that our approach provides rankings
that are close to human commonsense behavior and are far better than those obtained with
unstructured text retrieval tools.
8. Conclusion
We have addressed the matchmaking problem between descriptions from a DL perspective.
We have analyzed semantic-based matchmaking process and devised general commonsense
properties a matchmaker should have. We have also pointed out that classical inference
services of DLs, such as satisﬁability and subsumption, are needed and useful, but may be
not suﬃcient to cope with challenges posed by matchmaking in an open environment.
Motivated by this we have studied Concept Abduction and Contraction as novel non-
monotonic inferences in DLs suitable for modeling semantic-based matchmaking scenarios.
We analyzed minimality criteria, and proved simple complexity results. We also presented
reasonable algorithms for classifying and ranking matches based on the devised inferences
in terms of penalty functions, and proved that they obey to properties individuated.
Although several other measures may be determined to compute a score for “most
promising” matches our proposal has logical foundations and we have empyrically shown it
is able to well simulate commonsense human reasoning. Obviously, as any other semantic-
based approach, also our own has to rely on well-designed ontologies able to model the
application domain being considered.
Based on the theoretical work we have implemented a fully functional matchmaking
facilitator, oriented to both generic e-marketplace advertisements and to semantic-based
web-service discovery, which exploits state of art technologies and protocols, and it is, to
the best of our knowledge, the only running system able to cope with Concept Abduction
and Concept Contraction problems.
With speciﬁc reference to earlier work of the authors on the subject, Di Sciascio et al.
(2001) deﬁned matchmaking as satisﬁability of concept conjunction. Deﬁnitions of potential
match and near-miss i.e., partial match, in terms of abduction and belief-revision were out-
lined, and the need for ranking of matches motivated, in the work of Di Sciascio, Donini, and
Mongiello (2002). Di Noia et al. (2003b, 2003c) proposed a semantic-based categorization of
matches, logic-based ranking of matches within categories, and properties ranking functions
should have, in the framework of E-marketplaces. An extended and revised version of such
works is in (Di Noia, Di Sciascio, Donini, & Mongiello, 2004). Di Noia et al. (2003a) intro-
300
Semantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach
duced Concept Abduction in DLs and presented algorithms to solve a Concept Abduction
Problem in ALN . Colucci et al. (2003) proposed both Concept Abduction and Concept
Contraction as inferences suitable for semantic-matchmaking and explanation services. Cal`ı
et al. (2004) proposed a basic approach adopting penalty functions ranking, in the frame-
work of dating systems. Colucci et al. (2004) proposed initial results and algorithms based
on truth-preﬁxed tableau to solve Concept Abduction and Contraction problems in ALN .
Colucci et al. (2005) showed that such services can be usefully adopted both for semantic-
matchmaking and for ﬁnding negotiation spaces in an E-Commerce setting. The use of the
proposed inference services for reﬁnement purposes in the semantic-matchmaking process
has been outlined in the work of Colucci et al. (2006).
Our current research is oriented to the investigation of algorithms for more expressive
DLs and the development of a tableaux-based system for the proposed inference services.
Acknowledgments
We are grateful to the anonymous reviewers for comments and suggestions that improved the
quality of this paper. We thank Andrea Cal`ı and Diego Calvanese for useful discussions, and
in particular for suggesting the term “penalty function”. Simona Colucci, Azzurra Ragone,
Marina Mongiello and all the people at SisInfLab gave us invaluable help and suggestions.
This research has been supported by EU FP-6 IST STREP TOWL co. 026896.
Appendix A. Rules for Normal Form
The normal form of a concept can be obtained by repeatedly applying the rules of the two
following Sections, until no rule is applicable at any level of nesting of concepts inside ∀R.C.
A.1 Rules Involving Subconcepts
In the following rules, the  symbol on the l.h.s. should be considered as an associative and
commutative operator; hence, for instance, when writing (≥ n R) (≤ m R) in the second
rule, this should be read as the concepts (≥ n R) and (≤ m R) appear in any order inside
a conjunction of two or more concepts.
C  ⊥ → ⊥
(≥ n R)  (≤ m R) → ⊥ if n > m
A  ¬A → ⊥
(≥ n R)  (≥ m R) → (≥ n R) if n > m
(≤ n R)  (≤ m R) → (≤ n R) if n < m
∀R.D1  ∀R.D2 → ∀R.(D1 D2)
∀R.⊥ → ∀R.⊥  (≤ 0 R)
301
Di Noia, Di Sciascio & Donini
A.2 Rules Involving the Concept and the TBox
A → A  C if A  C ∈ T
A → C if A ≡ C ∈ T
A → A  ¬B1  · · ·  ¬Bk if disj (A,B1, . . . , Bk) ∈ T
Usually the concept resulting from the application of the above rules is referred to as an
expansion, or unfolding of a TBox.
A.3 Properties of the Normal Form
Let C be a concept in Classic, and let C ′ be any concept obtained from C by repeatedly
appying the above rules. Let |C|, |C ′| denote the size of C,C ′ respectively. It can be proved
(Borgida & Patel-Schneider, 1994) that:
1. if |C ′| is polynomially bounded in |C|, then C ′ can be computed in time O(|C|2);
2. every concept resulting from the application of the rules is equivalent to C, w.r.t.
models of the TBox.
As a consequence of the latter property, C is unsatisﬁable iﬀ its normal form is ⊥. Then,
as a consequence of the former property, unsatisﬁability can be decided in polynomial time
(Borgida & Patel-Schneider, 1994). The fact that |C ′| is polynomially bounded in |C| has
been intuitively related by Nebel (1990) to the form of TBoxes, that should be “bushy but
not deep”. A more precise deﬁnition has been given by Colucci et al. (2004).
References
Agarwal, S., & Lamparter, S. (2005). smart - a semantic matchmaking portal for electronic
markets. In Proceedings of the 7th International IEEE Conference on E-Commerce
Technology 2005.
Arens, Y., Knoblock, C. A., & Shen, W. (1996). Query Reformulation for Dynamic Infor-
mation Integration. Journal of Intelligent Information Systems, 6, 99–130.
Baader, F., Calvanese, D., Mc Guinness, D., Nardi, D., & Patel-Schneider, P. (Eds.). (2003).
The Description Logic Handbook. Cambridge University Press.
Baader, F., & Hollunder, B. (1992). Computing extensions of terminological default theories.
In Proceedings of ECAI Workshop on Knowledge Representation and Reasoning, pp.
30–52.
Baader, F., Ku¨sters, R., Borgida, A., & Mc Guinness, D. (1999). Matching in Description
Logics. Journal of Logic and Computation, 9 (3), 411–447.
Baader, F., Ku¨sters, R., & Molitor, R. (2000). Rewriting concepts using terminologies.
In Proceedings of the Seventh International Conference on Principles of Knowledge
Representation and Reasoning (KR’2000), pp. 297–308.
302
Semantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach
Benatallah, B., Hacid, M.-S., Rey, C., & Toumani, F. (2003). Request Rewriting-Based Web
Service Discovery. In International Semantic Web Conference, Vol. 2870 of Lecture
Notes in Computer Science, pp. 242–257. Springer.
Berners-Lee, T., Hendler, J., & Lassila, O. (2001). The semantic web. Scientiﬁc American,
248 (4), 34–43.
Bollmann, P., Jochum, F., Reiner, U., Weissmann, V., & Zuse, H. (1985). The LIVE-
Project-Retrieval experiments based on evaluation viewpoints. In Proceedings of the
8th Annual International ACM/SIGIR Conference on Research and Development in
Information Retrieval, pp. 213–214. ACM, New York.
Bonatti, P., Lutz, C., & Wolter, F. (2006). Description logics with circumscription. In
Proceedings of the Tenth International Conference on Principles of Knowledge Rep-
resentation and Reasoning (KR’2006), pp. 400–410.
Borgida, A., Brachman, R. J., McGuinness, D. L., & A. Resnick, L. (1989). CLASSIC: A
Structural Data Model for Objects. In Proceedings of the ACM SIGMOD International
Conference on Management of Data, pp. 59–67.
Borgida, A., & Patel-Schneider, P. F. (1994). A Semantics and Complete Algorithm for
Subsumption in the CLASSIC Description Logic. Journal of Artiﬁcial Intelligence
Research, 1, 277–308.
Brandt, S., Ku¨sters, R., & Turhan, A. (2002). Approximation and diﬀerence in descrip-
tion logics. In Proceedings of the Eight International Conference on Principles of
Knowledge Representation and Reasoning (KR’2002), pp. 203–214. MK.
Buchheit, M., Donini, F., Nutt, W., & Schaerf, A. (1998). A reﬁned architecture for ter-
minological systems: Terminology = schema + views. Artiﬁcial Intelligence, 99 (2),
209–260.
Cal`ı, A., Calvanese, D., Colucci, S., Di Noia, T., & Donini, F. M. (2004). A description logic
based approach for matching user proﬁles. In Proceedings of the 17th International
Workshop on Description Logics (DL’04), Vol. 104 of CEUR Workshop Proceedings.
Calvanese, D. (1996). Reasoning with Inclusion Axioms in Description Logics. In Proceedings
of the Twelfth European Conference on Artiﬁcial Intelligence (ECAI’96), pp. 303–307.
John Wiley & Sons.
Calvanese, D., De Giacomo, G., & Lenzerini, M. (1998). On the Decidability of Query
Containment under Constraints. In Proceedings of the Seventeenth ACM SIGACT
SIGMOD SIGART Symposium on Principles of Database Systems (PODS’98), pp.
149–158.
Colucci, S., Di Noia, T., Di Sciascio, E., Donini, F., & Mongiello, M. (2003). Concept Abduc-
tion and Contraction in Description Logics. In Proceedings of the 16th International
Workshop on Description Logics (DL’03), Vol. 81 of CEUR Workshop Proceedings.
Colucci, S., Di Noia, T., Di Sciascio, E., Donini, F., & Mongiello, M. (2004). A Uniform
Tableaux-Based Approach to Concept Abduction and Contraction in ALN. In Pro-
ceedings of the 17th International Workshop on Description Logics (DL’04), Vol. 104
of CEUR Workshop Proceedings.
303
Di Noia, Di Sciascio & Donini
Colucci, S., Di Noia, T., Di Sciascio, E., Donini, F., & Mongiello, M. (2005). Concept
Abduction and Contraction for Semantic-based Discovery of Matches and Negotiation
Spaces in an E-Marketplace. Electronic Commerce Research and Applications, 4 (4),
345–361.
Colucci, S., Di Noia, T., Di Sciascio, E., Donini, F., Ragone, A., & Rizzi, R. (2006). A
semantic-based fully visual application for matchmaking and query reﬁnement in B2C
e-marketplaces. In 8th International conference on Electronic Commerce, ICEC 06,
pp. 174–184. ACM Press.
Console, L., Dupre, D., & Torasso, P. (1991). On the Relationship between Abduction and
Deduction. Journal of Logic and Computation, 1 (5), 661–690.
Devambu, P., Brachman, R. J., Selfridge, P. J., & Ballard, B. W. (1991). LASSIE: A
Knowledge-Based Software Information System. Communications of the ACM, 34 (5),
36–49.
Di Noia, T., Di Sciascio, E., Donini, F., & Mongiello, M. (2003a). Abductive matchmaking
using description logics. In Proceedings of the Eighteenth International Joint Confer-
ence on Artiﬁcial Intelligence (IJCAI 2003), pp. 337–342.
Di Noia, T., Di Sciascio, E., Donini, F., & Mongiello, M. (2003b). Semantic matchmaking
in a P-2-P electronic marketplace. In Proc. Symposium on Applied Computing (SAC
’03), pp. 582–586. ACM.
Di Noia, T., Di Sciascio, E., Donini, F., & Mongiello, M. (2003c). A system for principled
Matchmaking in an electronic marketplace. In Proc. International World Wide Web
Conference (WWW ’03), pp. 321–330. ACM, New York.
Di Noia, T., Di Sciascio, E., Donini, F., & Mongiello, M. (2004). A system for princi-
pled Matchmaking in an electronic marketplace. International Journal of Electronic
Commerce, 8 (4), 9–37.
Di Sciascio, E., Donini, F., & Mongiello, M. (2002). Knowledge representation for match-
making in P2P e-commerce. In Atti dell’VIII Convegno dell’Associazione Italiana di
Intelligenza Artiﬁciale, Siena.
Di Sciascio, E., Donini, F., Mongiello, M., & Piscitelli, G. (2001). A Knowledge-Based Sys-
tem for Person-to-Person E-Commerce. In Proceedings of the KI-2001 Workshop on
Applications of Description Logics (ADL-2001), Vol. 44 of CEUR Workshop Proceed-
ings.
Donini, F. M. (2003). Complexity of reasoning. In Description Logics Handbook, chap. 3.
Cambridge University Press.
Donini, F. M., Lenzerini, M., Nardi, D., & Nutt, W. (1991). The Complexity of Con-
cept Languages. In Allen, J., Fikes, R., & Sandewall, E. (Eds.), Proceedings of the
Second International Conference on the Principles of Knowledge Representation and
Reasoning (KR’91), pp. 151–162. Morgan Kaufmann, Los Altos.
Donini, F. M., Nardi, D., & Rosati, R. (1997a). Autoepistemic description logics. In Proc.
of IJCAI ’97, pp. 136–141.
304
Semantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach
Donini, F. M., Lenzerini, M., Nardi, D., & Nutt, W. (1997b). The complexity of concept
languages. Information and Computation, 134, 1–58.
Eiter, T., & Gottlob, G. (1995). The Complexity of Logic-Based Abduction. Journal of the
ACM, 42 (1), 3–42.
Finin, T., Fritzson, R., McKay, D., & McEntire, R. (1994). KQML as an Agent Communica-
tion Language. In Proceedings of the Third International Conference on Information
and Knowledge Management (CIKM’94), pp. 456–463. ACM.
Ga¨rdenfors, P. (1988). Knowledge in Flux: Modeling the Dynamics of Epistemic States.
Bradford Books, MIT Press, Cambridge, MA.
Gil, Y., & Ramachandran, S. (2001). PHOSPHORUS: a Task based Agent Matchmaker.
In Proc. International Conference on Autonomous Agents ’01, pp. 110–111. ACM.
Gonzales-Castillo, J., Trastour, D., & Bartolini, C. (2001). Description Logics for Match-
making of Services. In Proceedings of the KI-2001 Workshop on Applications of De-
scription Logics (ADL-2001), Vol. 44. CEUR Workshop Proceedings.
Grimm, S., Motik, B., & Preist, C. (2006). Matching Semantic Service Descriptions with
Local Closed-World Reasoning. In European Semantic Web Conference, pp. 575–589.
Haarslev, V., & Mo¨ller, R. (2003). The dig description logic interface. In Proceedings of the
International Workshop on Description Logics (DL-2003), Vol. 81 of CEUR Workshop
Proceedings.
Horrocks, I., & Tobies, S. (2000). Reasoning with axioms: Theory and practice.. In Pro-
ceedings of the Seventh International Conference on Principles of Knowledge Repre-
sentation and Reasoning (KR’2000), pp. 285–296.
Jacobs, N., & Shea, R. (1995). Carnot and Infosleuth – Database Technology and the Web.
In Proceedings of the ACM SIGMOD International Conference on Management of
Data, pp. 443–444. ACM.
Jones, D., Bench-Capon, T., & Visser, P. (1998). Methodologies for ontology development.
In J. Cuena, editor, Proc. 15th IFIP World Computer Congress, pp. 62–75, London,
UK. Chapman and Hall.
Karacapilidis, N., & Moraitis, P. (2001). Building an Agent-Mediated Electronic Commerce
System with Decision Analysis Features. Decision Support Systems, 32, 53–69.
Kießling, W. (2002). Foundations of preferences in database systems. In Proceedings of the
Twentyeight International Conference on Very Large Data Bases (VLDB 2002).
Klusch, M., Fries, B., Khalid, M., & Sycara, K. (2005). Owls-mx: Hybrid owl-s service
matchmaking. In Proceedings of 1st Intl. AAAI Fall Symposium on Agents and the
Semantic Web.
Kuokka, D., & Harada, L. (1996). Integrating Information Via Matchmaking. Journal of
Intelligent Information Systems, 6, 261–279.
Li, L., & Horrocks, I. (2003). A Software Framework for Matchmaking Based on Semantic
Web Technology. In Proc. International World Wide Web Conference (WWW ’03),
pp. 331–339. ACM, New York.
305
Di Noia, Di Sciascio & Donini
Lutz, C. (1999). Reasoning with concrete domains. In Dean, T. (Ed.), Proceedings of the
Sixteenth International Joint Conference on Artiﬁcial Intelligence (IJCAI’99), pp.
90–95, Stockholm, Sweden. Morgan Kaufmann, Los Altos.
Madhavan, J., Bernstein, P., & Rahm, E. (2001). Generic schema matching with cupid. In
Proceedings of the Twentyseventh International Conference on Very Large Data Bases
(VLDB 2001), pp. 49–58.
Maes, P., Guttman, R., & Moukas, A. (1999). Agents that Buy and Sell. Communications
of the ACM, 42 (3), 81–91.
Motro, A. (1988). VAGUE: A User Interface to Relational Databases that Permits Vague
Queries. ACM Transactions on Oﬃce Information Systems, 6 (3), 187–214.
Nebel, B. (1990). Terminological Reasoning is Inherently Intractable. Artiﬁcial Intelligence,
43, 235–249.
N.F. Noy and D.L. McGuinness (2001). Ontology Development 101: A Guide to Creating
Your First Ontology. Stanford Knowledge Systems Laboratory Technical Report KSL-
01-05.
Paolucci, M., Kawamura, T., Payne, T., & Sycara, K. (2002). Semantic Matching of Web
Services Capabilities. In The Semantic Web - ISWC 2002, No. 2342 in Lecture Notes
in Computer Science, pp. 333–347. Springer-Verlag.
Peirce, C. . (1955). Abduction and induction. In Philosophical Writings of Peirce, chap. 11.
J. Buchler.
Ragone, A., Di Noia, T., Di Sciascio, E., Donini, F., Colucci, S., & Colasuonno, F. (2007).
Fully Automated Web Services Discovery and Composition through Concept Covering
and Concept Abduction. International Journal of Web Services Research (JWSR),
4 (3).
Raman, R., Livny, M., & Solomon, M. (1998). Matchmaking: distributed resource man-
agement for high throughput computing. In Proceedings of IEEE High Performance
Distributed Computing Conf., pp. 140–146.
Salton, G., & Gill, M. M. (1983). Introduction to Modern Information Retrieval. McGraw-
Hill, New York.
Schmidt-Schauß, M., & Smolka, G. (1991). Attributive Concept Descriptions with Comple-
ments. Artiﬁcial Intelligence, 48 (1), 1–26.
Shvaiko, P., & Euzenat, J. (2005). A survey of schema-based matching approaches. Journal
on Data Semantics, 4, 146–171.
Stro¨bel, M., & Stolze, M. (2002). A Matchmaking Component for the Discovery of Agree-
ment and Negotiation Spaces in Electronic Markets. Group Decision and Negotiation,
11, 165–181.
Sycara, K., Paolucci, M., Van Velsen, M., & Giampapa, J. (2003). The RETSINA MAS
infrastructure. Autonomous agents and multi-agent systems, 7, 29–48.
Sycara, K., Widoﬀ, S., Klusch, M., & Lu, J. (2002). LARKS: Dynamic Matchmaking Among
Heterogeneus Software Agents in Cyberspace. Autonomous agents and multi-agent
systems, 5, 173–203.
306
Semantic Matchmaking as Non-Monotonic Reasoning: A Description Logic Approach
Teege, G. (1994). Making the diﬀerence: A subtraction operation for description logics. In
Proceedings of the Fourth International Conference on the Principles of Knowledge
Representation and Reasoning (KR’94), pp. 540–550. MK.
Trastour, D., Bartolini, C., & Priest, C. (2002). Semantic Web Support for the Business-to-
Business E-Commerce Lifecycle. In Proc. International World Wide Web Conference
(WWW) ’02, pp. 89–98. ACM.
Veit, D., Muller, J., Schneider, M., & Fiehn, B. (2001). Matchmaking for Autonomous
Agents in Electronic Marketplaces. In Proc. International Conference on Autonomous
Agents ’01, pp. 65–66. ACM.
Wang, H., Liao, S., & Liao, L. (2002). Modeling Constraint-Based Negotiating Agents.
Decision Support Systems, 33, 201–217.
Wright, J. R., Weixelbaum, E. S., Vesonder, G. T., Brown, K. E., Palmer, S. R., Berman,
J. I., & Moore, H. H. (1993). A Knowledge-Based Conﬁgurator that Supports Sales,
Engineering, and Manufacturing at AT&T Network Systems. AI Magazine, 14 (3),
69–80.
307
